namespace DeadSprintV2
{
    internal abstract class CreepManager
    {
        public static float HoardGrowAmt = .1f;
        public static float SpreadReq = 5f;
        public static float SpreadThroughBrickReq = 100;

        public static float HoardIncrementAmmount = .000001f;

        static CreepManager()
        {
        }

        public static void update()
        {
            HoardGrowAmt += HoardIncrementAmmount;
            SpreadReq += HoardIncrementAmmount;
            SpreadThroughBrickReq += HoardIncrementAmmount;
        }
    }
}﻿using System.Collections.Generic;
using Microsoft.Xna.Framework;
using Microsoft.Xna.Framework.Graphics;
using NCodeRiddian;

namespace DeadSprintV2
{
    internal class DEBUG_DRAW
    {
        public static List<LineDefinition> DRAW_LINES = new List<LineDefinition>();

        public static void Add_Line(Vector2[] line, Color c)
        {
            LineDefinition ld = new LineDefinition();
            ld.line = line;
            ld.c = c;
            DRAW_LINES.Add(ld);
        }

        public static void Draw(SpriteBatch sb)
        {
            foreach (LineDefinition line in DRAW_LINES)
            {
                Camera.drawLineGeneric(line.line[0], line.line[1], sb, line.c);
            }
        }
    }

    public struct LineDefinition
    {
        public Vector2[] line;
        public Color c;
    }
}﻿using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using Microsoft.Xna.Framework;
using Microsoft.Xna.Framework.Graphics;
using Microsoft.Xna.Framework.Content;
using NCodeRiddian;

namespace DeadSprintV2
{
    class FloatingText
    {
        string text;
        Vector2 position;
        int timeLeft;
        Color c;

        static SpriteFont font;
        static List<FloatingText> FloatingTexts;

        public static void Load(ContentManager cm)
        {
            font = cm.Load<SpriteFont>("ftext");
            FloatingTexts = new List<FloatingText>();
        }

        public static void Update()
        {
            foreach (FloatingText ft in FloatingTexts)
                ft.update();
            FloatingTexts.RemoveAll(x => x.timeLeft <= 0);
        }

        public static void Draw(SpriteBatch sb)
        {
            foreach (FloatingText ft in FloatingTexts)
                ft.draw(sb);
        }

        public static void AddNew(string tx, Vector2 p, int ti, Color c)
        {
            FloatingTexts.Add(new FloatingText(tx, p, ti, c));
        }

        public FloatingText(string tx, Vector2 p, int ti, Color c)
        {
            text = tx;
            position = p;
            timeLeft = ti;
            this.c = c;
        }

        public void update()
        {
            position.Y--;
            timeLeft--;
        }

        public void draw(SpriteBatch sb)
        {
            Camera.drawString(sb, font, text, position, c, 0, Vector2.Zero, SpriteEffects.None, 0);
        }
    }
}
﻿using System.Collections.Generic;
using Microsoft.Xna.Framework;
using Microsoft.Xna.Framework.Graphics;
using NCodeRiddian;

namespace DeadSprintV2
{
    internal class Fog
    {
        private const int FOG_QUEUE_MAX = 250;
        private const int MenuFogSize = 100;
        private static ImageSet allFogs;
        private static Queue<Fog> fogQueue;

        public static void Setup()
        {
            allFogs = new ImageSet();
            allFogs.addSet(0);
            bool done = false;
            for (int x = 0; !done && x < 100; x++)
            {
                Image i = new Image("fogs\\" + x);
                if (i.getTexture() == null)
                {
                    done = true;
                }
                else
                {
                    allFogs[0] = i;
                }
            }
            fogQueue = new Queue<Fog>();
        }

        public static Fog NewFog(Vector2 v2)
        {
            if (fogQueue.Count > 0)
            {
                Fog forout = fogQueue.Dequeue();
                forout.Dequeue_me(v2);
                return forout;
            }
            return new Fog(v2);
        }

        public static void DeleteFog(Fog fg)
        {
            if (fogQueue.Count < FOG_QUEUE_MAX)
                fogQueue.Enqueue(fg);
        }

        private float dir;
        private float spd;
        private Vector2 pos;
        private bool isReversing;
        private Image myImg;

        public Fog(float dir, float spd, Vector2 pos)
        {
            Dequeue_me(dir, spd, pos);
            isReversing = false;
            myImg = allFogs.getRandomImage(0);
        }

        public Fog(Vector2 pos)
            : this((float)(GlobalRandom.random.NextDouble() * MathHelper.TwoPi), (float)(GlobalRandom.random.NextDouble() * 1f) + .1f, pos)
        {
        }

        private void Dequeue_me(float dir, float spd, Vector2 pos)
        {
            this.dir = dir;
            this.spd = spd;
            this.pos = pos;
            myImg = allFogs.getRandomImage(0);
        }

        private void Dequeue_me(Vector2 pos)
        {
            Dequeue_me((float)(GlobalRandom.random.NextDouble() * MathHelper.TwoPi), (float)(GlobalRandom.random.NextDouble() * 1f) + .1f, pos);
        }

        public Rectangle getBounds()
        {
            return MemSave.getr((int)pos.X, (int)pos.Y, myImg.getTexture().Width, myImg.getTexture().Height);
        }

        public Rectangle getBounds_Menu()
        {
            return MemSave.getr((int)pos.X - MenuFogSize, (int)pos.Y - MenuFogSize, 2 * MenuFogSize, 2 * MenuFogSize);
        }

        public void setPosition(Vector2 v)
        {
            pos = v;
        }

        public void Reverse()
        {
            dir += MathHelper.Pi;
            dir %= MathHelper.TwoPi;
            update();
            isReversing = !isReversing;
        }

        public void update()
        {
            pos = LocationManager.moveByRotation(pos, spd, dir);
        }

        public void Draw(SpriteBatch sb, Color c)
        {
            Camera.drawNoCheck(sb, myImg, MemSave.getr((int)pos.X, (int)pos.Y, myImg.getTexture().Width * 2, myImg.getTexture().Height * 2), c, null, dir + (isReversing ? MathHelper.Pi : 0), MemSave.getv(myImg.getTexture().Width, myImg.getTexture().Height), SpriteEffects.None, 0);
        }

        public void Draw_Menu(SpriteBatch sb, Color c)
        {
            Camera.drawNoCheck(sb, myImg, MemSave.getr((int)pos.X, (int)pos.Y, MenuFogSize * 2, MenuFogSize * 2), c, null, dir + (isReversing ? MathHelper.Pi : 0), MemSave.getv(MenuFogSize, MenuFogSize), SpriteEffects.None, 0);
        }
    }
}﻿using Microsoft.Xna.Framework.Content;
using Microsoft.Xna.Framework.Graphics;

namespace DeadSprintV2
{
    internal class FontManager
    {
        public static SpriteFont debugFont;

        public static void Load(ContentManager cm)
        {
            debugFont = cm.Load<SpriteFont>("DebugFont");
        }
    }
}using System;
using System.Collections.Generic;
using Microsoft.Xna.Framework;
using Microsoft.Xna.Framework.Graphics;
using Microsoft.Xna.Framework.Input;
using NCodeRiddian;

namespace DeadSprintV2
{
    /// <summary>
    /// This is the main type for your game
    /// </summary>
    public class Game1 : Microsoft.Xna.Framework.Game
    {
        private GraphicsDeviceManager graphics;
        private SpriteBatch spriteBatch;
        private Point ScreenSize;
        public static List<Player> players = new List<Player>();
        private static int numPlayers = 2;

        public Game1()
        {
            graphics = new GraphicsDeviceManager(this);
            Content.RootDirectory = "Content";
            //To go FullScreen
            /*
            graphics.ToggleFullScreen();
            ScreenSize = new Point(GraphicsAdapter.DefaultAdapter.CurrentDisplayMode.Width, GraphicsAdapter.DefaultAdapter.CurrentDisplayMode.Height);
            graphics.PreferredBackBufferWidth = ScreenSize.X;
            graphics.PreferredBackBufferHeight = ScreenSize.Y;*/

            ScreenSize = new Point(1400, 800);
            graphics.PreferredBackBufferWidth = ScreenSize.X;
            graphics.PreferredBackBufferHeight = ScreenSize.Y;
        }

        /// <summary>
        /// Allows the game to perform any initialization it needs to before starting to run.
        /// This is where it can query for any required services and load any non-graphic
        /// related content.  Calling base.Initialize will enumerate through any components
        /// and initialize them as well.
        /// </summary>
        protected override void Initialize()
        {
            // TODO: Add your initialization logic here
            OPTIONS.FullScreen = ScreenSize;

            base.Initialize();
        }

        /// <summary>
        /// LoadContent will be called once per game and is the place to load
        /// all of your content.
        /// </summary>
        protected override void LoadContent()
        {
            // Create a new SpriteBatch, which can be used to draw textures.
            spriteBatch = new SpriteBatch(GraphicsDevice);
            TextureManager.loadAllImages(Content);
            TextureManager.setDebug(true);
            Tile.LOAD_CONTENT();
            FontManager.Load(Content);
            RoomDefinition.LoadAllRooms();
            Map.SETUP();
            Fog.Setup();

            MainMenu.SETUP();

            Camera.setupGenericTexture(GraphicsDevice);
            MultiCamera.SETUP(ScreenSize, GraphicsDevice);
            players = new List<Player>();
            WeaponStats.LOAD_ALL_WEAPON_DATA();
            Camera.setupCamera(OPTIONS.FullScreen);
            SongManager.loadContent(Content);
            GuiManager.Load(Content);
            FloatingText.Load(Content);
            // TODO: use this.Content to load your game content here
        }

        public static Player getClosest(Point p)
        {
            int dist = (players[0].position.X / Tile.SIZE - p.X) + (players[0].position.Y / Tile.SIZE - p.Y);
            int idx = 1;
            int tidx = 0;
            while (idx++ < players.Count)
            {
                int ndist = (players[idx].position.X / Tile.SIZE - p.X) + (players[idx].position.Y / Tile.SIZE - p.Y);
                if (ndist < dist)
                {
                    dist = ndist;
                    tidx = idx;
                }
            }
            return players[tidx];
        }

        public void START_GAME(int pcount)
        {
            numPlayers = pcount;
            if (numPlayers == 1)
            {
                players.Add(new Player(new MultiCamera(new Rectangle(0, 0, ScreenSize.X, ScreenSize.Y), GraphicsDevice), PlayerIndex.One));
                OPTIONS.SingleScreen = new Point(ScreenSize.X, ScreenSize.Y);
            }
            else if (numPlayers == 2)
            {
                players.Add(new Player(new MultiCamera(new Rectangle(0, 0, ScreenSize.X, ScreenSize.Y / 2), GraphicsDevice), PlayerIndex.One));
                players.Add(new Player(new MultiCamera(new Rectangle(0, ScreenSize.Y / 2, ScreenSize.X, ScreenSize.Y / 2), GraphicsDevice), PlayerIndex.Two));
                OPTIONS.SingleScreen = new Point(ScreenSize.X, ScreenSize.Y / 2);
            }
            else if (numPlayers == 3)
            {
                players.Add(new Player(new MultiCamera(new Rectangle(0, 0, ScreenSize.X / 2, ScreenSize.Y / 2), GraphicsDevice), PlayerIndex.One));
                players.Add(new Player(new MultiCamera(new Rectangle(0, ScreenSize.Y / 2, ScreenSize.X / 2, ScreenSize.Y / 2), GraphicsDevice), PlayerIndex.Two));
                players.Add(new Player(new MultiCamera(new Rectangle(ScreenSize.X / 2, ScreenSize.Y / 4, ScreenSize.X / 2, ScreenSize.Y / 2), GraphicsDevice), PlayerIndex.Three));
                OPTIONS.SingleScreen = new Point(ScreenSize.X / 2, ScreenSize.Y / 2);
            }
            else if (numPlayers == 4)
            {
                players.Add(new Player(new MultiCamera(new Rectangle(0, 0, ScreenSize.X / 2, ScreenSize.Y / 2), GraphicsDevice), PlayerIndex.One));
                players.Add(new Player(new MultiCamera(new Rectangle(0, ScreenSize.Y / 2, ScreenSize.X, ScreenSize.Y / 2), GraphicsDevice), PlayerIndex.Two));
                players.Add(new Player(new MultiCamera(new Rectangle(ScreenSize.X / 2, 0, ScreenSize.X / 2, ScreenSize.Y / 2), GraphicsDevice), PlayerIndex.One));
                players.Add(new Player(new MultiCamera(new Rectangle(ScreenSize.X / 2, ScreenSize.Y / 2, ScreenSize.X / 2, ScreenSize.Y / 2), GraphicsDevice), PlayerIndex.Two));
                OPTIONS.SingleScreen = new Point(ScreenSize.X / 2, ScreenSize.Y / 2);
            }
            Shop.setupTargets();
            ParticleStuff.ALL_PARTICLES.Particles.Clear();
            ParticleStuff.ALL_PARTICLES.ActiveEffects.Clear();
            Glow.LOAD();
            Camera.setupCamera(OPTIONS.SingleScreen);
            OPTIONS.IS_IN_GAME = true;
            GuiManager.setScale();
            GC.Collect();
        }

        /// <summary>
        /// UnloadContent will be called once per game and is the place to unload
        /// all content.
        /// </summary>
        protected override void UnloadContent()
        {
            // TODO: Unload any non ContentManager content here
        }

        /// <summary>
        /// Allows the game to run logic such as updating the world,
        /// checking for collisions, gathering input, and playing audio.
        /// </summary>
        /// <param name="gameTime">Provides a snapshot of timing values.</param>
        protected override void Update(GameTime gameTime)
        {
            // Allows the game to exit
            if (GamePad.GetState(PlayerIndex.One).IsButtonDown(Buttons.Back))
                Exit();
            SongManager.update(OPTIONS.IS_IN_GAME);
            ParticleStuff.Update();
            KeyboardInputManager.update();
            if (OPTIONS.IS_IN_GAME)
            {
                ProjectileManager.update();
                foreach (Player p in players)
                {
                    if (p.myCamera.CameraLocation.X + ScreenSize.X + (Tile.SIZE * 2) > Map.fullWidth)
                        Map.generate();
                }
                foreach (Player p in players)
                    p.Update();
                Map.Deupdate();

                Map.UpdateHoard();
                CreepManager.update();
                FloatingText.Update();
            }
            else
            {
                MainMenu.update(this);
            }
            base.Update(gameTime);
        }

        /// <summary>
        /// This is called when the game should draw itself.
        /// </summary>
        /// <param name="gameTime">Provides a snapshot of timing values.</param>
        protected override void Draw(GameTime gameTime)
        {
            if (OPTIONS.IS_IN_GAME)
            {
                foreach (Player p in players)
                    p.Draw(spriteBatch);
                MultiCamera.FINISH(spriteBatch);
                spriteBatch.Begin();
                spriteBatch.Draw(Camera.getGeneric(), new Rectangle(0, 0, ScreenSize.X, ScreenSize.Y), Color.Black);
                MultiCamera.RENDER(spriteBatch);
                if (players.Count == 2)
                {
                    spriteBatch.Draw(Camera.getGeneric(), new Rectangle(0, ScreenSize.Y / 2, ScreenSize.X, 1), Color.Black);
                }
                else if (players.Count == 3)
                {
                    spriteBatch.Draw(Camera.getGeneric(), new Rectangle(ScreenSize.X / 2, 0, 1, ScreenSize.Y), Color.Black);
                    spriteBatch.Draw(Camera.getGeneric(), new Rectangle(0, ScreenSize.Y / 2, ScreenSize.X / 2, 1), Color.Black);
                }
                else if (players.Count == 4)
                {
                    spriteBatch.Draw(Camera.getGeneric(), new Rectangle(ScreenSize.X / 2, 0, 1, ScreenSize.Y), Color.Black);
                    spriteBatch.Draw(Camera.getGeneric(), new Rectangle(0, ScreenSize.Y / 2, ScreenSize.X, 1), Color.Black);
                }

                spriteBatch.End();
            }
            else
            {
                spriteBatch.Begin();
                MainMenu.Draw(spriteBatch);
                ParticleStuff.Draw(spriteBatch);
                spriteBatch.End();
            }

            base.Draw(gameTime);
        }
    }
}﻿using System.Collections.Generic;
using Microsoft.Xna.Framework;
using Microsoft.Xna.Framework.Graphics;
using NCodeRiddian;

namespace DeadSprintV2
{
    internal class GlowManager
    {
        public static List<Glow> glows = new List<Glow>();

        public static void addGlow(Glow g)
        {
            glows.Add(g);
        }

        public static void DrawAll(SpriteBatch sb)
        {
            if(!OPTIONS.SUB_OPTIONS.DISABLE_FLASH)
                foreach (Glow g in glows)
                    g.Draw(sb);
        }
    }

    internal class Glow
    {
        public static void LOAD()
        {
            image = new Image("glow_fire");
        }

        public Rectangle position;
        public static Image image;

        public void Draw(SpriteBatch sb)
        {
            if (!OPTIONS.SUB_OPTIONS.DISABLE_FLASH)
                Camera.draw(sb, image, position);
        }
    }
}﻿using System;
using Microsoft.Xna.Framework;
using Microsoft.Xna.Framework.Content;
using Microsoft.Xna.Framework.Graphics;
using NCodeRiddian;

namespace DeadSprintV2
{
    internal class GuiManager
    {
        private static Image top;
        private static Image bottom;
        private static Image topBar;
        private static Image[] TypeImages;
        private static SpriteFont AmmoFont;
        private static float scale;

        public static void Load(ContentManager cm)
        {
            top = new Image("gui\\topgui");
            bottom = new Image("gui\\bottomgui");
            topBar = new Image("gui\\topguibar");
            TypeImages = new Image[] { new Image("gui\\weaponicons\\hg"), new Image("gui\\weaponicons\\sg"), new Image("gui\\weaponicons\\ar"), new Image("gui\\weaponicons\\lr"), };
            AmmoFont = cm.Load<SpriteFont>("gui\\AmmoFont");
        }

        public static void setScale()
        {
            scale = Math.Min((float)OPTIONS.SingleScreen.X / (float)OPTIONS.FullScreen.X, (float)OPTIONS.SingleScreen.Y / (float)OPTIONS.FullScreen.Y);
        }

        public static int getScaleX(int orig)
        {
            return (int)(orig * scale);
        }

        public static int getScaleY(int orig)
        {
            return (int)(orig * scale);
        }

        public static void Draw(SpriteBatch sb, Player p)
        {
            sb.Draw(top.getTexture(), MemSave.getr(0, 0, getScaleX(150), getScaleY(109)), Color.White);
            sb.Draw(topBar.getTexture(), MemSave.getr(getScaleX(150), 0, getScaleX(1150), getScaleY(19)), Color.White);
            int money = p.imoney();
            string text = money + "";
            if (money > 1000)
                text = (int)(money / 1000) + (money < 100000 ? "." + (int)(money / 100 % 10) + "k" : "k");
            if (money > 1000000)
                text = (int)(money / 1000000) + "M";
            sb.DrawString(AmmoFont, "$" + text, MemSave.getv(getScaleX(2), getScaleY(8)), Color.Yellow);
            sb.Draw(bottom.getTexture(), MemSave.getr(0, OPTIONS.SingleScreen.Y - getScaleY(100), getScaleX(150), getScaleY(100)), Color.White);
            sb.Draw(Camera.getGeneric(), MemSave.getr(getScaleX(150), getScaleX(10), getScaleX((int)(1112 * (p.CurrentSprint / Player.MAX_SPRINT))), getScaleY(8)), Color.Green);
            int wsx = getScaleX(100);
            int wsy = (int)(TypeImages[(byte)p.currentWeapon().stats.type].getTexture().Height * ((float)wsx / TypeImages[(byte)p.currentWeapon().stats.type].getTexture().Width));
            sb.Draw(TypeImages[(byte)p.currentWeapon().stats.type].getTexture(), MemSave.getr(getScaleX(3), OPTIONS.SingleScreen.Y - getScaleY(97), wsx, wsy), Color.White);
            if (p.currentWeapon().ammo.Count == 0)
                text = "0";
            else
            {
                if (p.currentWeapon().currentReload != 0 && p.currentWeapon().ammo.First.Value == p.currentWeapon().stats.clipSize)
                    text = "--";
                else
                {
                    text = p.currentWeapon().ammo.Count + "";
                }
            }
            sb.DrawString(AmmoFont, text, MemSave.getv(3, OPTIONS.SingleScreen.Y - 25), text.Equals("0") ? Color.Red : Color.Black);
        }
    }
}﻿using System;
using System.Collections.Generic;
using Microsoft.Xna.Framework;
using Microsoft.Xna.Framework.Graphics;
using Microsoft.Xna.Framework.Input;
using NCodeRiddian;

namespace DeadSprintV2
{
    internal static class MainMenu
    {
        private static Image background;
        private static Image overImage;
        private static bool[] playersIn;
        private static Image[] pjoins;
        private static int maxTime;
        private static int time;
        private static bool flip;

        private static List<Fog> foggis;

        public static void SETUP()
        {
            background = new Image("menubase");
            overImage = new Image("menuover");
            playersIn = new bool[4];
            OPTIONS.PLAYER_COUNT = 0;
            pjoins = new Image[] { new Image("1connect"), new Image("2connect"), new Image("3connect"), new Image("4connect") };
            flip = false;
            maxTime = 340;
            time = 0;
            for (int x = 0; x < 20; x++)
            {
                ParticleStuff.AddDirectionalBlackness(MathHelper.PiOver2, x * OPTIONS.FullScreen.X / 20, (x + 1) * OPTIONS.FullScreen.X / 20, 0, 0);
                ParticleStuff.AddDirectionalBlackness(MathHelper.PiOver2 * 3, x * OPTIONS.FullScreen.X / 20, (x + 1) * OPTIONS.FullScreen.X / 20, OPTIONS.FullScreen.Y, OPTIONS.FullScreen.Y);
                ParticleStuff.AddDirectionalBlackness(0, 0, 0, x * OPTIONS.FullScreen.Y / 20, (x + 1) * OPTIONS.FullScreen.Y / 20);
                ParticleStuff.AddDirectionalBlackness(MathHelper.Pi, OPTIONS.FullScreen.X, OPTIONS.FullScreen.X, x * OPTIONS.FullScreen.Y / 20, (x + 1) * OPTIONS.FullScreen.Y / 20);
            }
            foggis = new List<Fog>();
            for (int x = 0; x < 75; x++)
                foggis.Add(new Fog((float)(MathHelper.TwoPi * GlobalRandom.random.NextDouble()), .4f, new Vector2((float)(GlobalRandom.random.NextDouble() * OPTIONS.FullScreen.X), (float)(GlobalRandom.random.NextDouble() * OPTIONS.FullScreen.Y))));
        }

        public static void update(Game1 game)
        {
            for (int x = 0; x < 4; x++)
            {
                if (!playersIn[x])
                {
                    if ((GamePad.GetState((PlayerIndex)x).IsConnected && GamePad.GetState((PlayerIndex)x).IsButtonDown(Buttons.Start)) || x == 1 && KeyboardInputManager.isKeyDown(Keys.S))
                    {
                        OPTIONS.PLAYER_COUNT++;
                        playersIn[x] = true;
                    }
                }
            }
            if (KeyboardInputManager.isKeyPressed(Keys.T))
            {
                for (int x = 0; x < 4; x++)
                    playersIn[x] = true;
                OPTIONS.PLAYER_COUNT = 4;
            }
            if (KeyboardInputManager.isKeyPressed(Keys.Y))
            {
                for (int x = 0; x < 3; x++)
                    playersIn[x] = true;
                OPTIONS.PLAYER_COUNT = 3;
            }

            time += (GlobalRandom.random.Next(3) + 1) * (flip ? 1 : -1);
            if (time > maxTime || time < 0)
            {
                flip = !flip;
                time = Math.Max(0, Math.Min(time, maxTime));
            }
            if (KeyboardInputManager.isKeyDown(Keys.Enter))
                game.START_GAME(OPTIONS.PLAYER_COUNT);

            foreach (Fog f in foggis)
            {
                f.update();
                Rectangle bounds = f.getBounds_Menu();
                if (bounds.X + bounds.Width < 0 || bounds.X > OPTIONS.FullScreen.X || bounds.Y + bounds.Height < 0 || bounds.Y > OPTIONS.FullScreen.Y)
                {
                    f.Reverse();
                    f.update();
                }
            }
        }

        public static float getFactor()
        {
            return (float)time / (float)maxTime;
        }

        public static void Draw(SpriteBatch sb)
        {
            sb.Draw((Texture2D)background, new Rectangle(0, 0, OPTIONS.FullScreen.X, OPTIONS.FullScreen.Y), Color.White);
            foreach (Fog f in foggis)
                f.Draw_Menu(sb, Color.Black);
            for (int x = 0; x < 4; x++)
            {
                if (playersIn[x])
                {
                    sb.Draw((Texture2D)pjoins[x], new Rectangle(OPTIONS.FullScreen.X / 6 * (1 + x), OPTIONS.FullScreen.Y / 8 * 3, OPTIONS.FullScreen.X / 8, OPTIONS.FullScreen.X / 8), Color.White);
                }
            }

            sb.Draw((Texture2D)overImage, new Rectangle((int)-(OPTIONS.FullScreen.X * .1 * getFactor()), (int)-(OPTIONS.FullScreen.Y * .1 * getFactor()), (int)(OPTIONS.FullScreen.X * (1 + .2 * getFactor())), (int)(OPTIONS.FullScreen.Y * (1 + .2 * getFactor()))), Color.White);
        }
    }
}﻿using System;
using System.Collections.Generic;
using System.Linq;
using Microsoft.Xna.Framework;
using Microsoft.Xna.Framework.Graphics;
using NCodeRiddian;

namespace DeadSprintV2
{
    internal class Map
    {
        public const int TILEHEIGHT = 12;
        public static int fullWidth;

        public static int hoarddist = 1;

        private static List<Tile>[] Tiles = new List<Tile>[TILEHEIGHT];

        public static void SETUP()
        {
            for (int x = 0; x < TILEHEIGHT; x++)
                Tiles[x] = new List<Tile>();
            generate();
            generate();

            for (int y = 0; y < TILEHEIGHT; y++)
            {
                Tiles[y][0].hasHoard = true;
                Tiles[y][0].hoardValue = .1f;
            }
        }

        public static short curout = 0;

        public static void generate()
        {
            List<RoomDefinition> pnext = new List<RoomDefinition>();
            foreach (RoomDefinition r in RoomDefinition.allRooms)
            {
                if (r.input == curout)
                    pnext.Add(r);
            }

            RoomDefinition use = pnext[GlobalRandom.random.Next(pnext.Count)];
            curout = use.output;
            fullWidth += use.width * Tile.SIZE;
            for (int y = 0; y < TILEHEIGHT; y++)
            {
                for (int x = 0; x < use.width; x++)
                {
                    Tiles[y].Add(new Tile(new Point(Tiles[y].Count, y), use.getTile(x, y)));
                }
            }
        }

        public static Tile getTile(Point p)
        {
            return Tiles[p.Y][p.X];
        }

        public static Tile getTile(int x, int y)
        {
            return Tiles[y][x];
        }

        public static int getWidth()
        {
            return Tiles[0].Count;
        }

        public static Tile.TileType getTileType(Point p)
        {
            return Tiles[p.Y][p.X].type;
        }

        public static List<List<Tile>> getTiles(Rectangle r)
        {
            List<List<Tile>> outp = new List<List<Tile>>();

            for (int y = r.Y / Tile.SIZE; y <= (r.Y + r.Height - 1) / Tile.SIZE; y++)
            {
                outp.Add(new List<Tile>());
                for (int x = r.X / Tile.SIZE; x <= (r.X + r.Width - 1) / Tile.SIZE; x++)
                {
                    outp.Last().Add(Tiles[y][x]);
                }
            }

            return outp;
        }

        public static void Update(Rectangle r)
        {
            for (int x = Math.Max(0, r.X / Tile.SIZE - 3); x < Math.Min(Tiles[0].Count, (r.X + r.Width) / Tile.SIZE + 3); x++)
            {
                for (int y = 0; y < TILEHEIGHT; y++)
                {
                    Tiles[y][x].Update();
                }
            }
        }

        public static void Deupdate()
        {
            foreach (List<Tile> tl in Tiles)
            {
                foreach (Tile t in tl)
                {
                    t.deUpdate();
                }
            }
        }

        public static void UpdateHoard()
        {
            for (int x = 0; x < Tiles[0].Count; x++)
            {
                for (int y = 0; y < TILEHEIGHT; y++)
                {
                    Tiles[y][x].HoardUpdate();
                }
            }/*
            int difference = (hoarddist/ Tile.SIZE - Tiles[0][0].mapPosition.X);
            Console.Out.WriteLine("HD:" + hoarddist / Tile.SIZE + " TP:" + Tiles[0][0].mapPosition.X);
            if(difference > 30)
                Console.Out.WriteLine("Dif > 30. Removing " + (difference - 30));
            for(int x = 0; x < (difference - 30); x++)
            {
                foreach (List<Tile> t in Tiles)
                    t.RemoveAt(0);
            }*/
        }

        public static void Draw(SpriteBatch sb, Rectangle r)
        {
            for (int x = Math.Max(0, r.X / Tile.SIZE - 3); x < Math.Min(Tiles[0].Count, (r.X + r.Width) / Tile.SIZE + 3); x++)
            {
                for (int y = 0; y < TILEHEIGHT; y++)
                {
                    Tiles[y][x].Draw(sb);
                }
            }
        }

        public static void FogDraw(SpriteBatch sb, Rectangle r)
        {
            for (int x = Math.Max(0, r.X / Tile.SIZE - 3); x < Math.Min(Tiles[0].Count, (r.X + r.Width) / Tile.SIZE + 3); x++)
            {
                for (int y = 0; y < TILEHEIGHT; y++)
                {
                    Tiles[y][x].DrawFog(sb);
                }
            }
        }
    }
}﻿using Microsoft.Xna.Framework;

namespace DeadSprintV2
{
    internal abstract class OPTIONS
    {
        public static bool IS_IN_GAME = false;
        public static int PLAYER_COUNT = 1;
        public static Point FullScreen;
        public static Point SingleScreen;
        public static SubOptions SUB_OPTIONS = new SubOptions(false);

        public struct SubOptions
        {
            public bool DISABLE_FOG;
            public bool DISABLE_FLASH;

            public SubOptions(bool all)
            {
                DISABLE_FLASH = all;
                DISABLE_FOG = all;
            }
        }
    }
}﻿using System;
using Microsoft.Xna.Framework;
using Microsoft.Xna.Framework.Graphics;
using NCodeRiddian;

namespace DeadSprintV2
{
    internal static class ParticleStuff
    {
        private const int GLOWSIZE = 6;

        public static ParticleManager2 ALL_PARTICLES = new ParticleManager2();
        public static Image OverlayFire;
        public static Image OverlayWhite;

        static ParticleStuff()
        {
            OverlayFire = new Image("glow_fire_faint");
            OverlayWhite = new Image("glow_white");
        }

        public static void ParticleOverdraw(Particle2 p, SpriteBatch sb)
        {
            Camera.draw(sb, OverlayFire, MemSave.getr((int)p.position.X + (p.size / 2) - p.size * (GLOWSIZE / 2), (int)p.position.Y + (p.size / 2) - p.size * (GLOWSIZE / 2), p.size * GLOWSIZE, p.size * GLOWSIZE));
        }

        public static void DirectionalFireUpdate(Particle2 p)
        {
            p.position = LocationManager.moveByRotation(p.position, p.velocity.X, p.velocity.Y);
            p.velocity.Y += (((float)GlobalRandom.random.NextDouble() * .1f) - .05f) * p.velocity.X;
            p.velocity.X *= (float)(GlobalRandom.random.NextDouble() * .08) + .9f;
            p.size += GlobalRandom.random.Next(10) == 0 ? -1 : 0;
            p.size = Math.Min(3, Math.Max(1, p.size));
            if (p.velocity.X < .4f)
                p.isActive = false;
        }

        public static void DarkParticleEffect(Particle2 p)
        {
            p.position = LocationManager.moveByRotation(p.position, p.velocity.X, p.velocity.Y);
            p.size += GlobalRandom.random.Next(12) == 0 ? -1 : 0;
            if (p.size < 1)
                p.isActive = false;
        }

        public static Particle2[] DirectionalFireSpawnerEffect(ParticleEffect2 pe)
        {
            float angle = (float)pe.param[0];
            float velocity = (float)pe.param[1];
            int amt = (int)pe.param[4];
            Particle2[] returnp = new Particle2[amt];
            for (int x = 0; x < amt; x++)
            {
                returnp[x] = Particle2.GetNew((Vector2)pe.param[2], new Vector2((float)(GlobalRandom.random.NextDouble() * velocity), angle), DirectionalFireUpdate, ParticleManager2.COLORSET_FIRE.getRandomColor(), GlobalRandom.random.Next(5) + 1);
                returnp[x].DrawUnder = ParticleOverdraw;
            }
            if ((int)pe.param[3] < pe.time)
                pe.isActive = false;
            return returnp;
        }

        public static Particle2[] DirectionalBlacknessEffect(ParticleEffect2 e2)
        {
            float angle = (float)e2.param[0];
            Particle2[] returnp = new Particle2[2];
            for (int x = 0; x < 2; x++)
            {
                returnp[x] = Particle2.GetNew(new Vector2(between((float)e2.param[1], (float)e2.param[2]), between((float)e2.param[3], (float)e2.param[4])), new Vector2((float)(GlobalRandom.random.NextDouble() * 1.5), angle + (float)(GlobalRandom.random.NextDouble() * .2) - .1f), DarkParticleEffect, Color.Black, 8);
            }
            if (OPTIONS.IS_IN_GAME)
                e2.isActive = false;
            return returnp;
        }

        public static float between(float f1, float f2)
        {
            return (float)((GlobalRandom.random.NextDouble() * (f2 - f1)) + f1);
        }

        public static void AddDirectionalBlackness(float angle, float mix, float max, float miy, float may)
        {
            ALL_PARTICLES.ActiveEffects.Add(new ParticleEffect2(DirectionalBlacknessEffect, new object[] { angle, mix, max, miy, may }));
        }

        public static void addDirectionalFireEffect(float angle, float velocity, Vector2 position, int lifetime, int amt)
        {
            ALL_PARTICLES.ActiveEffects.Add(new ParticleEffect2(DirectionalFireSpawnerEffect, new object[] { angle, velocity, position, lifetime, amt }));
        }

        public static void Update()
        {
            ALL_PARTICLES.update();
        }

        public static void Draw(SpriteBatch sb)
        {
            ALL_PARTICLES.Draw(sb);
        }
    }
}﻿using System;
using System.Collections;
using System.Collections.Generic;
using Microsoft.Xna.Framework;
using Microsoft.Xna.Framework.Graphics;
using Microsoft.Xna.Framework.Input;
using NCodeRiddian;

namespace DeadSprintV2
{
    public class Player
    {
        private const float WALK_SPEED = 5;
        private const float SPRINT_SPEED = 8;
        public const float MAX_SPRINT = 30f;
        private const float SPRINT_DRAIN_RATE = .3f;
        private const float SPRINT_GROW_RATE_WALK = .06f;
        private const float SPRINT_GROW_RATE_STAND = .2f;
        private const float SPRINT_DOOR_BREAK = 3f;
        private const float SPRINT_TABLE_DIVE = 1.5f;
        private const float AIM_DIST = 300f;
        private const int TABLE_JUMP_SPEED = 8;

        public MultiCamera myCamera;
        public Rectangle position;
        public Vector2 aimPoint;
        public Vector2 movePoint;
        public Vector2 oldMovePoint;
        private bool isTableJumping;
        private int tableJumpDir = 0;
        private bool isSprinting;
        public float CurrentSprint;
        private bool BlockX;
        private bool BlockY;
        private bool isTriggerDown;
        private bool isTriggerPressed;
        private float leftmotor;
        private float rightmotor;
        public float money;

        private Weapon PrimaryWeapon;
        private Weapon secondaryWeapon;
        private bool isUsingPrimary;
        public float angle;
        public int myCameraShake;

        private PlayerAction currentAction;

        private int goingToTableJump;

        private PlayerIndex index;

        public Shop myShop;

        public Player(MultiCamera mc, PlayerIndex indx)
        {
            CurrentSprint = MAX_SPRINT;
            myCamera = mc;
            index = indx;
            isSprinting = false;
            position = new Rectangle(Tile.SIZE * (1 + (int)indx), Tile.SIZE * 3, Tile.SIZE / 4 * 3, Tile.SIZE / 4 * 3);
            goingToTableJump = -1;
            BlockX = false;
            BlockY = false;
            isUsingPrimary = true;
            PrimaryWeapon = new Weapon(WeaponStats.AllStats[0], this);
            secondaryWeapon = null;
            money = 0;
            myCameraShake = 0;
            myShop = new Shop();
        }

        public int imoney()
        {
            return (int)money;
        }


        public bool isTable(Tile.TileType t)
        {
            return t == Tile.TileType.TableBottom || t == Tile.TileType.TableTop || t == Tile.TileType.TableLeft || t == Tile.TileType.TableRight;
        }

        public bool isDoor(Tile.TileType t)
        {
            return t == Tile.TileType.Door || t == Tile.TileType.DoorBottom || t == Tile.TileType.DoorTop;
        }
        #region AllColisionMethods

        public void collide(Tile t, bool isX)
        {
            if (isX)
            {
                BlockX = true;
                if (movePoint.X > 0)
                {
                    position.X = t.position.X - position.Width;
                }
                else
                {
                    position.X = t.position.X + t.position.Width;
                }
            }
            else
            {
                BlockY = true;
                if (movePoint.Y > 0)
                {
                    position.Y = t.position.Y - position.Height;
                }
                else
                {
                    position.Y = t.position.Y + t.position.Height;
                }
            }
        }

        public bool xcheck(Point p)
        {
            switch (Map.getTile(p).type)
            {
                case Tile.TileType.Open:
                    return false;
                case Tile.TileType.Closed:
                case Tile.TileType.Crates:
                case Tile.TileType.TableLeft:
                case Tile.TileType.TableRight:
                    return true;
                case Tile.TileType.DoorBottom:
                case Tile.TileType.Door:
                case Tile.TileType.DoorTop:
                    if (Map.getTile(p).additional)
                        return false;
                    if (isSprinting)
                    {
                        if (CurrentSprint >= SPRINT_DOOR_BREAK)
                        {
                            CurrentSprint -= SPRINT_DOOR_BREAK;
                            Map.getTile(p).additional = true;
                            return false;
                        }
                        return true;
                    }
                    else
                    {
                        return true;
                    }
                case Tile.TileType.TableBottom:
                case Tile.TileType.TableTop:
                    if (isSprinting)
                    {
                        if (Map.getTile(new Point(p.X + (movePoint.X > 0 ? 1 : -1), p.Y)).type == Tile.TileType.Open)
                        {
                            goingToTableJump = movePoint.X > 0 ? 0 : 2;
                            return false;
                        }
                        else
                            return true;
                    }
                    return true;
                default:
                    return true;
            }
        }

        public bool ycheck(Point p)
        {
            switch (Map.getTile(p).type)
            {
                case Tile.TileType.Open:
                    return false;
                case Tile.TileType.Closed:
                case Tile.TileType.Crates:
                case Tile.TileType.TableTop:
                case Tile.TileType.TableBottom:
                    return true;
                case Tile.TileType.DoorBottom:
                case Tile.TileType.Door:
                case Tile.TileType.DoorTop:
                    if (Map.getTile(p).additional)
                        return false;
                    if (isSprinting)
                    {
                        if (CurrentSprint >= SPRINT_DOOR_BREAK)
                        {
                            CurrentSprint -= SPRINT_DOOR_BREAK;
                            Map.getTile(p).additional = true;
                            return false;
                        }
                        return true;
                    }
                    else
                    {
                        return true;
                    }
                case Tile.TileType.TableLeft:
                case Tile.TileType.TableRight:
                    if (isSprinting)
                    {
                        if (Map.getTile(new Point(p.X, p.Y + (movePoint.Y > 0 ? 1 : -1))).type == Tile.TileType.Open)
                        {
                            goingToTableJump = movePoint.Y < 0 ? 1 : 3;
                            return false;
                        }
                        else
                            return true;
                    }
                    return true;
                default:
                    return true;
            }
        }

        public bool doXMove()
        {
            Point p1 = new Point((position.X + (int)Math.Ceiling(movePoint.X) + (movePoint.X > 0 ? position.Width : 0)) / Tile.SIZE, position.Y / Tile.SIZE), p2 = new Point((position.X + (int)Math.Ceiling(movePoint.X) + (movePoint.X > 0 ? position.Width : 0)) / Tile.SIZE, (position.Y + position.Height - 1) / Tile.SIZE);
           
            bool block = false;
            block = xcheck(p1);
            if (!block)
                block = xcheck(p2);
            if (!block)
            {
                position.X += (int)Math.Ceiling(movePoint.X);
                return false;
            }
            else
            {
                if (movePoint.X > 0)
                {
                    position.X = (p1.X * Tile.SIZE) - position.Width;
                }
                else
                {
                    position.X = (p1.X + 1) * Tile.SIZE;
                }
                return true;
            }
        }

        public bool doYMove()
        {
            Point p1 = new Point(position.X / Tile.SIZE, (position.Y + (int)Math.Ceiling(movePoint.Y) + (movePoint.Y > 0 ? position.Height : 0)) / Tile.SIZE), p2 = new Point((position.X + position.Width - 1) / Tile.SIZE, (position.Y + (int)Math.Ceiling(movePoint.Y) + (movePoint.Y > 0 ? position.Height : 0)) / Tile.SIZE);

            bool block = false;

            block = ycheck(p1);
            if (!block)
                block = ycheck(p2);
            if (!block)
            {
                position.Y += (int)Math.Ceiling(movePoint.Y);
                return false;
            }
            else
            {
                if (movePoint.Y > 0)
                {
                    position.Y = (p1.Y * Tile.SIZE) - position.Height;
                }
                else
                {
                    position.Y = (p1.Y + 1) * Tile.SIZE;
                }
                return true;
            }
        }
        #endregion

        public void setup(bool up)
        {
            if (up)
                currentWeapon().isSetup = true;
        }

        public Weapon currentWeapon()
        {
            return isUsingPrimary ? PrimaryWeapon : secondaryWeapon;
        }

        public void Update()
        {
            myShop.update();
            
            Map.Update(myCamera.getView());
            angle = float.NaN;
            if (currentAction != null)
            {
                if (currentAction.update())
                    currentAction = null;
                return;
            }

            if (!isTableJumping)
            {
                BlockX = false;
                BlockY = false;
                goingToTableJump = -1;
                isSprinting = GamePad.GetState(index).IsButtonDown(Buttons.LeftStick) && CurrentSprint > 0;
                movePoint = new Vector2(GamePad.GetState(index).ThumbSticks.Left.X * (isSprinting ? SPRINT_SPEED : WALK_SPEED), -GamePad.GetState(index).ThumbSticks.Left.Y * (isSprinting ? SPRINT_SPEED : WALK_SPEED));

                if (KeyboardInputManager.isKeyPressed(Keys.G))
                {
                    myShop.toggle();
                }

                ///BLOCK KEYMOVE
                if (KeyboardInputManager.isKeyDown(Keys.LeftShift))
                    isSprinting = CurrentSprint > 0;
                if (KeyboardInputManager.isKeyDown(Keys.A))
                    movePoint.X = -(isSprinting ? SPRINT_SPEED : WALK_SPEED);
                else if (KeyboardInputManager.isKeyDown(Keys.D))
                    movePoint.X = (isSprinting ? SPRINT_SPEED : WALK_SPEED);
                if (KeyboardInputManager.isKeyDown(Keys.W))
                    movePoint.Y = -(isSprinting ? SPRINT_SPEED : WALK_SPEED);
                else if (KeyboardInputManager.isKeyDown(Keys.S))
                    movePoint.Y = (isSprinting ? SPRINT_SPEED : WALK_SPEED);
                ///ENDBLOCK KEYMOVE
                ///

                if (movePoint.X != 0 || movePoint.Y != 0)
                {
                    oldMovePoint = movePoint;
                }
                if (currentAction != null)
                    movePoint = new Vector2(0, 0);

                #region Colision

                if (Math.Abs(movePoint.X) > Math.Abs(movePoint.Y))
                {
                    BlockX = doXMove();
                    if(goingToTableJump == -1 || BlockX)
                        BlockY = doYMove();
                }
                else
                {
                    BlockY = doYMove();
                    if (goingToTableJump == -1 || BlockY)
                        BlockX = doXMove();
                }

                #endregion Colision

                #region TableJumping

                if (goingToTableJump != -1)
                {
                    if ((goingToTableJump == 0 || goingToTableJump == 2))
                    {
                        if (!BlockX)
                        {
                            isTableJumping = true;
                            tableJumpDir = goingToTableJump;
                            CurrentSprint -= SPRINT_TABLE_DIVE;
                        }
                    }
                    else if ((goingToTableJump == 1 || goingToTableJump == 3) && !BlockY)
                    {
                        isTableJumping = true;
                        tableJumpDir = goingToTableJump;
                        CurrentSprint -= SPRINT_TABLE_DIVE;
                    }
                }
            }
            else
            {   // If Jumping a table
                switch (tableJumpDir)
                {
                    case 0:
                        position.X += TABLE_JUMP_SPEED;
                        break;

                    case 1:
                        position.Y -= TABLE_JUMP_SPEED;
                        break;

                    case 2:
                        position.X -= TABLE_JUMP_SPEED;
                        break;

                    case 3:
                        position.Y += TABLE_JUMP_SPEED;
                        break;
                }
                bool canBeDone = false;
                switch (Map.getTile(new Point(position.X / Tile.SIZE, position.Y / Tile.SIZE)).type)
                {
                    case Tile.TileType.Open:
                        canBeDone = true;
                        break;

                    case Tile.TileType.Door:
                    case Tile.TileType.DoorBottom:
                    case Tile.TileType.DoorTop:
                        if (Map.getTile(new Point(position.X / Tile.SIZE, position.Y / Tile.SIZE)).additional)
                        {
                            CurrentSprint -= SPRINT_DOOR_BREAK;
                            Map.getTile(new Point(position.X / Tile.SIZE, position.Y / Tile.SIZE)).additional = false;
                            canBeDone = true;
                        }
                        else
                        {
                            canBeDone = true;
                        }
                        break;
                }
                switch (Map.getTile(new Point((position.X + position.Width - 1) / Tile.SIZE, (position.Y + position.Height - 1) / Tile.SIZE)).type)
                {
                    case Tile.TileType.Open:
                        if (canBeDone)
                            isTableJumping = false;
                        break;

                    case Tile.TileType.Door:
                    case Tile.TileType.DoorBottom:
                    case Tile.TileType.DoorTop:
                        if (Map.getTile(new Point(position.X / Tile.SIZE, position.Y / Tile.SIZE)).additional)
                        {
                            CurrentSprint -= SPRINT_DOOR_BREAK;
                            Map.getTile(new Point(position.X / Tile.SIZE, position.Y / Tile.SIZE)).additional = false;
                            if (canBeDone)
                                isTableJumping = false;
                        }
                        else
                        {
                            if (canBeDone)
                                isTableJumping = false;
                        }
                        break;
                }
            }

                #endregion TableJumping

            aimPoint.X = position.Center.X + GamePad.GetState(index).ThumbSticks.Right.X * (float)currentWeapon().stats.SightRange;
            aimPoint.Y = position.Center.Y - GamePad.GetState(index).ThumbSticks.Right.Y * (float)currentWeapon().stats.SightRange;
            angle = (float)Math.Atan2(-GamePad.GetState(index).ThumbSticks.Right.Y, GamePad.GetState(index).ThumbSticks.Right.X);
            while (angle < MathHelper.TwoPi)
                angle += MathHelper.TwoPi;
            angle %= MathHelper.TwoPi;
            if (!myShop.isExpanded())
                myCamera.Center(aimPoint);
            else
                myCamera.Center(LocationManager.getVectorFromPoint(PointM.Add(LocationManager.getPointFromVector(aimPoint), myShop.currentWidth(), 0)));
            myCamera.advancedAssure(new Rectangle(0, 0, Map.fullWidth + 10, Map.TILEHEIGHT * Tile.SIZE));

            if (isSprinting && CurrentSprint <= .1f)
            {
                isSprinting = false;
                CurrentSprint = -10 * SPRINT_GROW_RATE_WALK;
            }

            if (!isTriggerPressed && !isTriggerDown && (GamePad.GetState(index).Triggers.Right > .8 || KeyboardInputManager.isKeyDown(Keys.LeftControl)))
            {
                isTriggerPressed = true;
            }
            else
                isTriggerPressed = false;
            isTriggerDown = (GamePad.GetState(index).Triggers.Right > .8 || KeyboardInputManager.isKeyDown(Keys.LeftControl));

            GamePad.SetVibration(index, Math.Min(1, leftmotor), Math.Min(1, rightmotor));
            if (GamePad.GetState(index).Buttons.RightShoulder == ButtonState.Pressed && currentWeapon().currentReload == 0)
                currentWeapon().Reload();
            rightmotor *= .85f;
            leftmotor *= .75f;
            if (currentWeapon().stats.isAutomatic)
            {
                if (isTriggerDown)
                {
                    currentWeapon().fire(this);
                }
            }
            else
            {
                if (isTriggerPressed)
                {
                    currentWeapon().fire(this);
                }
            }
            currentWeapon().update(this);

            if (isSprinting && !isTableJumping)
                CurrentSprint -= SPRINT_DRAIN_RATE;
            else if (CurrentSprint < MAX_SPRINT)
                CurrentSprint += Math.Min(SPRINT_GROW_RATE_WALK, MAX_SPRINT - CurrentSprint);

            if (currentAction == null && !isTableJumping)
            {
                if (GamePad.GetState(index).IsButtonDown(Buttons.A))
                {
                    List<Tile> possibleTargets = new List<Tile>();
                    int tx = position.Left / Tile.SIZE;
                    int ty = position.Top / Tile.SIZE;
                    int by = (position.Bottom - 1) / Tile.SIZE;
                    int bx = (position.Right - 1) / Tile.SIZE;
                    if (oldMovePoint.X > 0)
                    {
                        possibleTargets.Add(Map.getTile(new Point(bx + 1, ty)));
                        possibleTargets.Add(Map.getTile(new Point(bx + 1, by)));
                    }
                    else if (oldMovePoint.X < 0)
                    {
                        possibleTargets.Add(Map.getTile(new Point(tx - 1, ty)));
                        possibleTargets.Add(Map.getTile(new Point(tx - 1, by)));
                    }
                    if (oldMovePoint.Y > 0)
                    {
                        possibleTargets.Add(Map.getTile(new Point(tx, by + 1)));
                        possibleTargets.Add(Map.getTile(new Point(bx, by + 1)));
                    }
                    else if (oldMovePoint.Y < 0)
                    {
                        possibleTargets.Add(Map.getTile(new Point(tx, ty - 1)));
                        possibleTargets.Add(Map.getTile(new Point(bx, ty - 1)));
                    }
                    foreach (Tile t in possibleTargets)
                    {
                        if (isDoor(t.type))
                            currentAction = new DoorAction(t);
                    }
                    if (currentAction == null)
                    {
                        foreach (Tile t in possibleTargets)
                        {
                            if (t.type == Tile.TileType.Crates && !t.additional)
                                currentAction = new CrateAction(t, this);
                        }
                    }
                }
            }
            else if(currentAction != null)
                currentAction.update();
        }

        public void vibrate(float amt)
        {
            leftmotor = amt;
            rightmotor = amt;
            GamePad.SetVibration(index, 1, 1);
        }

        public void Draw(SpriteBatch sb)
        {
            myCamera.startRender(sb, Color.Black);

            Map.Draw(sb, myCamera.getView());

            foreach (Player p in Game1.players)
                Camera.drawGeneric(sb, p.position, Color.Blue, null, 0, Vector2.Zero, SpriteEffects.None, 0);

            if (currentAction != null)
                currentAction.draw(sb, new Point(position.Left, position.Bottom));

            ProjectileManager.Draw(sb);
            ParticleStuff.Draw(sb);
            GlowManager.DrawAll(sb);
            Map.FogDraw(sb, myCamera.getView());
            FloatingText.Draw(sb);
            GuiManager.Draw(sb, this);
            myShop.Draw(sb);

            DEBUG_DRAW.Draw(sb);
            myCamera.endRender(sb);
        }
    }
}﻿using Microsoft.Xna.Framework.Graphics;
using Microsoft.Xna.Framework;
using NCodeRiddian;

namespace DeadSprintV2
{
    abstract class PlayerAction
    {

        protected int Time;
        private int startingTime;

        public PlayerAction(int t)
        {
            Time = t;
            startingTime = t;
        }

        public bool update()
        {
            Time--;
            if (Time <= 0)
            {
                trigger();
                return true;
            }
            return false;
        }

        public abstract void trigger();

        public void draw(SpriteBatch sb, Point pt)
        {
            Camera.drawGeneric(sb, MemSave.getr(pt.X, pt.Y, Tile.SIZE / 4 * 3, 5), Color.Gray, null, 0, Vector2.Zero, SpriteEffects.None, 0);
            Camera.drawGeneric(sb, MemSave.getr(pt.X + 1, pt.Y + 1, (int)((Tile.SIZE / 4 * 3 - 2) * (1f - ((float)Time / startingTime))), 3), Color.Green, null, 0, Vector2.Zero, SpriteEffects.None, 0);
        }
    }

    internal class DoorAction : PlayerAction
    {
        Tile targetTile;

        public DoorAction(Tile t) : base(t.additional ? 20 : 60)
        {
            targetTile = t;
        }

        public override void trigger()
        {
            targetTile.additional = !targetTile.additional;
            if (targetTile.type == Tile.TileType.DoorTop)
            {
                if (Map.getTile(PointM.Add(targetTile.mapPosition, 0, 1)).additional != targetTile.additional)
                {
                    Map.getTile(PointM.Add(targetTile.mapPosition, 0, 1)).additional = targetTile.additional;
                }
            }
            if (targetTile.type == Tile.TileType.DoorBottom)
            {
                if (Map.getTile(PointM.Add(targetTile.mapPosition, 0, -1)).additional != targetTile.additional)
                {
                    Map.getTile(PointM.Add(targetTile.mapPosition, 0, -1)).additional = targetTile.additional;
                }
            }
        }
    }

    internal class WeaponSetup : PlayerAction
    {
        Player p;

        public WeaponSetup(Player p2)
            : base(p2.currentWeapon().stats.setupTime)
        {
            p = p2;
        }

        public override void trigger()
        {
            p.currentWeapon().isSetup = !p.currentWeapon().isSetup;
        }
    }

    internal class CrateAction : PlayerAction
    {
        Player p;
        Tile t;

        public CrateAction(Tile t, Player p2)
            : base(240)
        {
            p = p2;
            this.t = t;
        }

        public override void trigger()
        {
            if (!t.additional)  
            {
                t.additional = true;
                switch (GlobalRandom.random.Next(6))
                {
                    case 0:
                        int cn = GlobalRandom.random.Next(5);
                        for(int c = 0; c < cn; c++)
                            p.currentWeapon().ammo.AddLast(p.currentWeapon().stats.clipSize);
                        FloatingText.AddNew("Ammo: " + cn, LocationManager.getVectorFromPoint(p.position.Center), 90, Color.Blue);
                        break;
                    case 1:
                        cn = (int)GlobalRandom.NextBetween(50, 500);
                        p.money += cn;
                        FloatingText.AddNew("$" + cn, LocationManager.getVectorFromPoint(p.position.Center), 90, Color.Yellow);
                        break;
                    default:
                        FloatingText.AddNew("Nothing", LocationManager.getVectorFromPoint(p.position.Center), 80, Color.Red);
                        break;
                }
            }
        }
    }
}namespace DeadSprintV2
{
#if WINDOWS || XBOX

    internal static class Program
    {
        /// <summary>
        /// The main entry point for the application.
        /// </summary>
        private static void Main(string[] args)
        {
            using (Game1 game = new Game1())
            {
                game.Run();
            }
        }
    }

#endif
}﻿using System;
using System.Collections.Generic;
using Microsoft.Xna.Framework;
using Microsoft.Xna.Framework.Graphics;
using NCodeRiddian;

namespace DeadSprintV2
{
    internal class ProjectileManager
    {
        public static List<LineTrail> lines = new List<LineTrail>();

        public static void addLine(Vector2[] line, int t)
        {
            lines.Add(new LineTrail(line, t));
        }

        public static void update()
        {
            foreach (LineTrail l in lines)
            {
                l.upd();
            }
            lines.RemoveAll(x => x.time <= 0);
        }

        public static void Draw(SpriteBatch sb)
        {
            foreach (LineTrail line in lines)
            {
                Camera.drawLineGeneric(line.line[0], line.line[1], sb, Color.White, (int)Math.Log(line.time));
            }
        }
    }

    internal class LineTrail
    {
        public Vector2[] line;
        public int time;
        public int timestop;
        public Glow myGlow;

        public LineTrail(Vector2[] arr, int t)
        {
            line = arr;
            time = t;
            timestop = 3;
            myGlow = new Glow();
            myGlow.position = new Rectangle((int)arr[0].X - (500 / 2), (int)arr[0].Y - (500 / 2), 500, 500);

            GlowManager.glows.Add(myGlow);
        }

        public void upd()
        {
            timestop--;
            if (timestop <= 0)
            {
                time /= 2;
                timestop = 3;
            }

            myGlow.position.X += myGlow.position.Width / 4;
            myGlow.position.Y += myGlow.position.Height / 4;
            myGlow.position.Width /= 2;
            myGlow.position.Height /= 2;

            if (myGlow.position.Width < 3 || time <= 0)
                GlowManager.glows.Remove(myGlow);
        }
    }
}﻿using System;
using System.Collections.Generic;
using Microsoft.Xna.Framework;
using NCodeRiddian;

namespace DeadSprintV2
{
    internal class RoomDefinition
    {
        public static List<RoomDefinition> allRooms = new List<RoomDefinition>();

        public static void LoadAllRooms()
        {
            bool done = false;
            for (int r = 0; !done; r++)
            {
                Image i = new Image("Rooms\\" + r);
                if (i.getTexture() == null)
                    done = true;
                else
                {
                    Color[] colors = new Color[i.getTexture().Width * i.getTexture().Height];
                    i.getTexture().GetData<Color>(colors);
                    allRooms.Add(new RoomDefinition(colors));
                    int wid = i.getTexture().Width;
                }
            }

            for (int x = 0; x < allRooms.Count; x++)
            {
                int connectIn = 0;
                int connectOut = 0;
                for (int y = 0; y < allRooms.Count; y++)
                {
                    if (allRooms[x].input == allRooms[y].output)
                        connectIn++;
                    if (allRooms[x].output == allRooms[y].input)
                        connectOut++;
                }
                if (connectIn == 0 && allRooms[x].input != 0)
                    Console.Out.WriteLine("WARNING! Room " + x + " has no inputs!");
                if (connectOut == 0)
                    Console.Out.WriteLine("WARNING! Room " + x + " has no outputs!");
            }
        }

        /*
         * 0,0,0       - Blocked
         * 255,255,255 - Open
         * 255, 0, 0   - Open, NotPassage
         * 0, 255, 0   - Door / Double Door
         * 130, 130, 0 - Vert Table
         * 150, 150, 0 - Horz Table
         * 60, 60, 0   - Crate
         */

        public const int SIZE = 12;
        public short input;
        public short output;
        public int width;

        //TileType[,] tiles;
        private List<TileType>[] tiles;

        public byte getTile(int x, int y)
        {
            return (byte)tiles[y][x];
        }

        public RoomDefinition(Color[] data)
        {
            tiles = new List<TileType>[SIZE];
            int wid = data.Length / SIZE;
            width = wid;
            for (int a = 0; a < tiles.Length; a++)
            {
                tiles[a] = new List<TileType>();
                for (int x = 0; x < wid; x++)
                    tiles[a].Add(TileType.Unassigned);
            }
            for (int x = 0; x < wid; x++)
            {
                for (int y = 0; y < SIZE; y++)
                {
                    Color thiscolor = data[y * wid + x];
                    if (x == 0 || x == wid - 1)
                    {
                        if (thiscolor.Equals(new Color(255, 255, 255)) || thiscolor.Equals(new Color(0, 255, 0)))
                        {
                            if (x == 0)
                            {
                                input |= (short)(0x1 << y);
                            }
                            else
                            {
                                output |= (short)(0x1 << y);
                            }
                        }
                    }
                    if (tiles[y][x] == TileType.Unassigned)
                    {
                        tiles[y][x] = getFromColor(thiscolor);
                        if (tiles[y][x] == TileType.Door)
                        {
                            if (getFromColor(data[(y + 1) * SIZE + x]) == TileType.Door)
                            {
                                tiles[y][x] = TileType.DoorTop;
                                tiles[y + 1][x] = TileType.DoorBottom;
                            }
                        }
                        if (tiles[y][x] == TileType.TableLeft)
                            tiles[y][x + 1] = TileType.TableRight;
                        if (tiles[y][x] == TileType.TableTop)
                            tiles[y + 1][x] = TileType.TableBottom;
                    }
                }
            }
        }

        private enum TileType : byte
        {
            Unassigned = 0,
            Open = 1,
            OpenNP = 2,
            Closed = 3,
            Crates = 4,
            TableLeft = 5,
            TableRight = 6,
            TableTop = 7,
            TableBottom = 8,
            Door = 9,
            DoorTop = 10,
            DoorBottom = 11
        }

        private TileType getFromColor(Color c)
        {
            switch (c.R)
            {
                case 0:
                    return c.G == 255 ? TileType.Door : TileType.Closed;
                case 255:
                    return c.G == 255 ? TileType.Open : TileType.OpenNP;
                case 150:
                    return TileType.TableLeft;
                case 130:
                    return TileType.TableTop;
                case 60:
                    return TileType.Crates;
            }
            return TileType.Unassigned;
        }
    }
}﻿using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using Microsoft.Xna.Framework;
using Microsoft.Xna.Framework.Graphics;
using NCodeRiddian;
using Microsoft.Xna.Framework.Content;

namespace DeadSprintV2
{
    public class Shop
    {
        public const int SHOPWIDTH = 300;
        const int SPEED = 5;
        static int TARGET;

        static Point current;

        bool isMoving;
        bool isExpanding;

        public static void LOAD(ContentManager cm)
        {
        }

        public static void setupTargets()
        {
            current = new Point(OPTIONS.SingleScreen.X, 0);
            TARGET = OPTIONS.SingleScreen.X - SHOPWIDTH;
        }

        public void toggle()
        {
            isMoving = true;
            isExpanding = !isExpanding;
        }

        public bool isExpanded()
        {
            return isExpanding;
        }

        public int getCurrent()
        {
            return current.X;
        }

        public int getDifference()
        {
            return current.X - TARGET;
        }

        public int currentWidth()
        {
            return OPTIONS.SingleScreen.X - current.X;
        }

        public void update()
        {
            if (isMoving)
            {
                if (isExpanding)
                {
                    current.X -= SPEED;
                    if (current.X <= TARGET)
                    {
                        current.X = TARGET;
                        isMoving = false;
                    }
                }
                else
                {
                    current.X += SPEED;
                    if (current.X >= OPTIONS.SingleScreen.X)
                    {
                        isMoving = false;
                        current.X = OPTIONS.SingleScreen.X;
                    }
                }
            }
        }

        public Rectangle GetRect(Rectangle r)
        {
            if(current.X != TARGET)
                return new Rectangle(r.X + (current.X - TARGET), r.Y, r.Width, r.Height);
            return r;
        }

        public void Draw(SpriteBatch sb)
        {
            sb.Draw(Camera.getGeneric(), GetRect(MemSave.getr(TARGET, 0, SHOPWIDTH, OPTIONS.SingleScreen.Y)), Color.Gray);
        }
    }

    public class ShopCategory
    {
        List<WeaponStats> Contents;
        public bool isAccessed;
        public bool hide;

        public void Draw(SpriteBatch sb, Func<Rectangle, Rectangle> GetRect)
        {
            if (hide)
            {
                return;
            }
            if (isAccessed)
            {

            }
        }
    }
}
﻿using System;
using System.Timers;
using Microsoft.Xna.Framework.Audio;
using Microsoft.Xna.Framework.Content;
using Microsoft.Xna.Framework.Media;

namespace DeadSprintV2
{
    internal abstract class SongManager
    {
        private const int MILLIBUFFER = 300;

        private static SoundEffect DeadWhisperOpening;
        private static SoundEffect DeadWhisperLoop;
        private static SoundEffectInstance i1;
        private static SoundEffectInstance i2;
        private static Timer timer;
        private static Song MainTheme;
        private static bool hasStarted;
        private static bool playing1;

        public static void loadContent(ContentManager cm)
        {
            DeadWhisperOpening = cm.Load<SoundEffect>("The Dead Whisper_Opening");
            DeadWhisperLoop = cm.Load<SoundEffect>("The Dead Whisper_Loop");
            MainTheme = cm.Load<Song>("MainTheme");
            hasStarted = false;
        }

        public static void update(bool isInGame)
        {
            if (!isInGame)
            {
                if (!hasStarted)
                {
                    hasStarted = true;
                    playing1 = true;
                    i1 = DeadWhisperOpening.CreateInstance();
                    timer = new Timer(DeadWhisperOpening.Duration.TotalMilliseconds - MILLIBUFFER);
                    i1.Play();
                    timer.Start();
                    timer.AutoReset = true;
                    timer.Elapsed += new ElapsedEventHandler(timer_Elapsed);
                    i2 = DeadWhisperLoop.CreateInstance();
                }
            }
            else
            {
                timer.Stop();
                if (playing1)
                    i1.Volume = (float)Math.Max(0, i1.Volume - .1);
                else
                    i2.Volume = (float)Math.Max(0, i2.Volume - .1);
                if (MediaPlayer.State != MediaState.Playing)
                    MediaPlayer.Play(MainTheme);
            }
        }

        private static void timer_Elapsed(object sender, ElapsedEventArgs e)
        {
            ((Timer)sender).Interval = DeadWhisperLoop.Duration.TotalMilliseconds - MILLIBUFFER;
            if (playing1)
            {
                i2.Play();
                i1 = DeadWhisperLoop.CreateInstance();
            }
            else
            {
                i1.Play();
                i2 = DeadWhisperLoop.CreateInstance();
            }

            ((Timer)sender).Start();
            playing1 = !playing1;
        }
    }
}﻿using System;
using System.Collections.Generic;
using System.Linq;
using Microsoft.Xna.Framework;
using Microsoft.Xna.Framework.Graphics;
using NCodeRiddian;

namespace DeadSprintV2
{
    public class Tile : Pathable
    {
        public const int SIZE = 50;

        #region LOAD

        private static ImageSet imgset = new ImageSet();
        private static ImageSet creepImages = new ImageSet();

        public static void LOAD_CONTENT()
        {
            imgset.addSet(11);
            for (int x = 0; x < 12; x++)
            {
                bool isDone = false;
                for (int y = 0; !isDone && y < 20; y++)
                {
                    Image i = new Image("RoomSprites\\" + x + "\\" + y);
                    if (i.getTexture() == null)
                    {
                        isDone = true;
                    }
                    else
                    {
                        imgset.AddImage(x, i);
                    }
                }
            }
            bool dne = false;
            for (int x = 0; !dne; x++)
            {
                Image i = new Image("tilecreep\\" + x);
                if (i.getTexture() == null)
                    dne = true;
                else
                    creepImages.AddImage(0, i);
            }
        }

        #endregion LOAD

        private static Point[] UDLR = new Point[] { new Point(0, -1), new Point(0, 1), new Point(-1, 0), new Point(1, 0) };
        private const int FOG_DENSITY = 1;
        public const int DOOR_WID = 10;
        public TileType type;
        public Rectangle position;
        public Point mapPosition;
        private Image myImage;

        public float hoardValue;

        private List<Tile> adj;
        private List<Fog> myFog;
        public bool hasHoard;
        private bool hasUpdated;
        public bool LightUpFog;
        public bool LightUpFogRed;
        public bool LightUpFogWhite;
        public bool additional;
        public bool sleep;

        public Tile(Point p, byte t)
        {
            sleep = false;
            additional = false;
            type = (TileType)t;
            position = new Rectangle(p.X * SIZE, p.Y * SIZE, SIZE, SIZE);
            mapPosition = new Point(p.X, p.Y);
            myImage = imgset.getRandomImage(t);
            hasHoard = false;
            hasUpdated = false;
            LightUpFog = false;
            LightUpFogRed = false;

            myFog = new List<Fog>();
        }

        public void Update()
        {
            if (hasUpdated)
                return;
            hasUpdated = true;
            if (OPTIONS.SUB_OPTIONS.DISABLE_FOG)
                return;
            while (myFog.Count < (hasHoard ? FOG_DENSITY * 5 : FOG_DENSITY))
                myFog.Add(Fog.NewFog(MemSave.getv((float)(position.X + GlobalRandom.random.NextDouble() * SIZE), (float)(position.Y + GlobalRandom.random.NextDouble() * SIZE))));
            while (myFog.Count > (hasHoard ? FOG_DENSITY * 5 : FOG_DENSITY))
                myFog.RemoveAt(0);
            foreach (Fog f in myFog)
            {
                f.update();
                if (!position.Intersects(f.getBounds()))
                {
                    f.Reverse();
                }
            }
            LightUpFogRed = false;
            LightUpFogWhite = false;
            LightUpFog = false;
        }

        public void HoardUpdate()
        {
            if (hoardValue > 0)
            {
                hoardValue += CreepManager.HoardGrowAmt;
                if (position.X > Map.hoarddist)
                    Map.hoarddist = position.X;
            }

            if (hoardValue <= 0)
            {
                hoardValue /= 2;
                hasHoard = false;
                foreach (Tile t in getConnected().Cast<Tile>())
                {
                    t.sleep = false;
                }
            }

            if (hoardValue > CreepManager.SpreadReq)
            {
                hasHoard = true;
                if (!sleep)
                {
                    sleep = true;
                    if (adj == null)
                    {
                        adj = new List<Tile>();
                        foreach (Point dir in UDLR)
                        {
                            Point check = PointM.Add(mapPosition, dir.X, dir.Y);
                            if (check.X >= 0 && check.Y >= 0 && check.Y < Map.TILEHEIGHT && check.X < Map.getWidth() && Map.getTile(check).hoardPass())
                                adj.Add(Map.getTile(check));
                        }
                    }
                    foreach (Tile t in adj)
                    {
                        if (t.hoardValue == 0)
                            t.hoardValue = CreepManager.HoardGrowAmt;
                    }
                }
            }
            if (hoardValue > CreepManager.SpreadThroughBrickReq)
            {
                adj = new List<Tile>();
                foreach (Point dir in UDLR)
                {
                    Point check = PointM.Add(mapPosition, dir.X, dir.Y);
                    if (check.X >= 0 && check.Y >= 0 && check.Y < Map.TILEHEIGHT && check.X < Map.getWidth())
                        adj.Add(Map.getTile(check));
                }

                foreach (Tile t in adj)
                {
                    t.hoardValue = Math.Max(t.hoardValue, CreepManager.SpreadThroughBrickReq / 3);
                }
            }
        }

        public bool hoardPass()
        {
            return !(type == TileType.Closed || type == TileType.TableBottom || type == TileType.TableLeft || type == TileType.TableTop || type == TileType.TableRight);
        }

        public bool blocksBullets()
        {
            return (type == TileType.Closed || type == TileType.Crates || ((type == TileType.Door || type == TileType.DoorBottom || type == TileType.DoorTop) && !additional));
        }

        public void deUpdate()
        {
            if (OPTIONS.SUB_OPTIONS.DISABLE_FOG)
                return;
            if (!hasUpdated && myFog != null)
            {
                while (myFog.Count > 0)
                {
                    Fog.DeleteFog(myFog.Last());
                    myFog.Remove(myFog.Last());
                }
            }
            hasUpdated = false;
        }

        #region DrawFunctions

        public void Draw(SpriteBatch sb)
        {
            Camera.draw(sb, imgset.getImage(1, 0), position);
            if (hoardValue > CreepManager.SpreadThroughBrickReq)
            {
                Camera.drawGeneric(sb, position, new Color((float)(GlobalRandom.random.NextDouble() * .3f), 0, 0), null, 0, Vector2.Zero, SpriteEffects.None, 0);
            }
            else
            {
                if (myImage != null)
                {
                    if (additional && (type == TileType.Door || type == TileType.DoorBottom || type == TileType.DoorTop))
                    {
                        if (type == TileType.DoorBottom)
                        {
                            Camera.draw(sb, myImage, MemSave.getr(position.X + Tile.SIZE, position.Y, position.Width, position.Height), Color.White, null, -MathHelper.PiOver2, MemSave.getv(DOOR_WID, 0), SpriteEffects.None, 0);
                        }
                        else
                        {
                            Camera.draw(sb, myImage, position, Color.White, null, -MathHelper.PiOver2, MemSave.getv(DOOR_WID, 0), SpriteEffects.None, 0);
                        }
                    }
                    else
                    {
                        Camera.draw(sb, myImage, position, Color.White, null, 0, Vector2.Zero, SpriteEffects.None, 0);
                    }
                    if (hoardValue > CreepManager.SpreadReq)
                    {
                        Camera.draw(sb, creepImages.getRandomImage(0), position, new Color(GlobalRandom.random.Next(30), 0, 0), null, 0, Vector2.Zero, SpriteEffects.None, 0);
                    }
                }
            }
        }

        public void DrawFog(SpriteBatch sb)
        {
            if (OPTIONS.SUB_OPTIONS.DISABLE_FOG)
                return;
            foreach (Fog f in myFog)
            {
                f.Draw(sb, LightUpFogWhite ? Color.White : (LightUpFogRed ? Color.Red : (LightUpFog ? Color.Yellow : (hasHoard ? new Color((float)(GlobalRandom.random.NextDouble() * .3f), 0, 0) : Color.Gray))));
                LightUpFog = false;
            }
        }

        #endregion DrawFunctions

        public enum TileType : byte
        {
            Unassigned = 0,
            Open = 1,
            OpenNP = 2,
            Closed = 3,
            Crates = 4,
            TableLeft = 5,
            TableRight = 6,
            TableTop = 7,
            TableBottom = 8,
            Door = 9,
            DoorTop = 10,
            DoorBottom = 11
        }

        #region PATHABLE_FUNCTIONS

        public float getMoveScore(Pathable previous)
        {
            if (type == TileType.Door || type == TileType.DoorBottom || type == TileType.DoorTop)
                if (!additional)
                    return 1;
            return 1;
        }

        public float getHeuristicScore(Pathable target)
        {
            return (float)Math.Pow(((Tile)target).mapPosition.X - mapPosition.X, 2) + (float)Math.Pow((((Tile)target).mapPosition.Y - mapPosition.Y), 2);
        }

        public Rectangle getTrueRectangle()
        {
            return position;
        }

        public bool isValid()
        {
            return true;
        }

        public List<Pathable> getConnected()
        {
            List<Pathable> p = new List<Pathable>();
            if (mapPosition.X > 0 && !Map.getTile(mapPosition.X - 1, mapPosition.Y).blocksBullets())
                p.Add(Map.getTile(mapPosition.X - 1, mapPosition.Y));
            if (mapPosition.X < (Map.fullWidth / Tile.SIZE) - 1 && !Map.getTile(mapPosition.X + 1, mapPosition.Y).blocksBullets())
                p.Add(Map.getTile(mapPosition.X + 1, mapPosition.Y));
            if (mapPosition.Y > 0 && !Map.getTile(mapPosition.X, mapPosition.Y - 1).blocksBullets())
                p.Add(Map.getTile(mapPosition.X, mapPosition.Y - 1));
            if (mapPosition.Y < Map.TILEHEIGHT - 1 && !Map.getTile(mapPosition.X, mapPosition.Y + 1).blocksBullets())
                p.Add(Map.getTile(mapPosition.X, mapPosition.Y + 1));
            return p;
        }

        #endregion PATHABLE_FUNCTIONS
    }
}﻿using System;
using System.Collections.Generic;
using Microsoft.Xna.Framework;
using NCodeRiddian;

namespace DeadSprintV2
{
    public class Weapon
    {
        public WeaponStats stats;
        public static Random mrnd = new Random();

        public int currentReload;
        private int delayRemaining;
        private int projectileRemainaing;
        public LinkedList<int> ammo;
        private Player pl;

        public bool isSetup;

        public Weapon(WeaponStats s, Player p)
        {
            stats = s;
            ammo = new LinkedList<int>();
            currentReload = 0;
            delayRemaining = 0;
            projectileRemainaing = 0;
            for (int x = 0; x < s.startingAmmo / s.clipSize; x++)
            {
                ammo.AddFirst(s.clipSize);
            }
            pl = p;
            isSetup = false;
        }

        public bool fire(Player p)
        {
            if (currentReload != 0 || ammo.Count == 0 || ammo.First.Value <= 0 || (stats.reqiresSetup && !isSetup))
                return false;

            projectileRemainaing = stats.numberOfProjectiles;
            createProjectile(p);

            return true;
        }

        public void createProjectile(Player p)
        {
            if (ammo.Count == 0 || ammo.First.Value <= 0)
                return;

            ammo.First.Value--;
            projectileRemainaing--;
            pl.vibrate(stats.damageMin);
            SHOOT(p);

            if (projectileRemainaing > 0)
            {
                delayRemaining = stats.multiprojectileDelay;
            }
            else
            {
                currentReload = stats.reloadTime;
            }
            if (delayRemaining == 0 && projectileRemainaing > 0)
                createProjectile(p);
        }

        public void Reload()
        {
            if (ammo.Count > 0)
            {
                ammo.RemoveFirst();
                currentReload = stats.clipReloadTime;
            }
        }

        public void update(Player p)
        {
            if (projectileRemainaing > 0)
            {
                if (delayRemaining == 0)
                    createProjectile(p);
                else
                    delayRemaining--;
            }
            else
            {
                if (currentReload > 0)
                {
                    currentReload--;
                }
            }
        }

        public void SHOOT(Player p)
        {
            Vector2 startingPosition = LocationManager.getVectorFromPoint(pl.position.Center);
            float angle = pl.angle;

            if (float.IsNaN(angle))
            {
                angle = MathHelper.Pi;
            }

            angle += (float)((mrnd.NextDouble() * stats.accuracy) - (stats.accuracy / 2));

            while (angle < MathHelper.TwoPi)
                angle += MathHelper.TwoPi;
            angle %= MathHelper.TwoPi;

            double changex = Math.Cos(angle);
            double changey = Math.Sin(angle);
            if (Math.Abs(changex) > Math.Abs(changey))
            {
                changey = Math.Abs(changey / changex) * Math.Sign(changey);
                changex = Math.Sign(changex);
            }
            else
            {
                changex = Math.Abs(changex / changey) * Math.Sign(changex);
                changey = Math.Sign(changey);
            }
            int line1 = changex > 0 ? 3 : 1;
            int line2 = changey > 0 ? 0 : 2;

            Vector2 currentPosition = new Vector2(startingPosition.X, startingPosition.Y);
            bool isFlying = true;
            while (isFlying)
            {
                int x = (int)(currentPosition.X / Tile.SIZE),
                    y = (int)(currentPosition.Y / Tile.SIZE);

                if (x < 0 || y < 0 || x >= Map.fullWidth / Tile.SIZE || y >= Map.TILEHEIGHT)
                {
                    isFlying = false;
                }
                else
                {
                    if (Map.getTile(new Point(x, y)).hoardValue > 0)
                    {
                        float damage = (float)GlobalRandom.NextBetween(stats.damageMin, stats.damageMax);
                        p.money += Math.Min(damage, Map.getTile(new Point(x, y)).hoardValue);
                        Map.getTile(new Point(x, y)).hoardValue -= damage;
                    }
                    if (Map.getTile(new Point(x, y)).blocksBullets())
                    {
                        //DEBUG_DRAW.Add_Line(new Vector2[] { new Vector2(x * Tile.SIZE, y * Tile.SIZE), new Vector2((x * Tile.SIZE) + 10, (y * Tile.SIZE) + 10) }, Color.Blue);
                        //DEBUG_DRAW.Add_Line(new Vector2[] { new Vector2(x * Tile.SIZE, (y * Tile.SIZE) + 10), new Vector2((x * Tile.SIZE) + 10, (y * Tile.SIZE)) }, Color.Blue);
                        Vector2[][] lines = LocationManager.RectangleEdges(Map.getTile(new Point(x, y)).position);
                        Vector2[] SideLine = lines[line1];
                        Vector2[] TbLine = lines[line2];
                        Vector2 Intersection = new Vector2();
                        if (LocationManager.linesIntersect(startingPosition, currentPosition, SideLine[0], SideLine[1]))
                        {
                            Intersection = LocationManager.getReflectionLine(new Vector2[] { startingPosition, currentPosition }, SideLine)[0];

                            //DEBUG_DRAW.Add_Line(SideLine, Color.Green);
                        }
                        else if (LocationManager.linesIntersect(startingPosition, currentPosition, TbLine[0], TbLine[1]))
                        {
                            Intersection = LocationManager.getReflectionLine(new Vector2[] { startingPosition, currentPosition }, TbLine)[0];

                            // DEBUG_DRAW.Add_Line(TbLine, Color.Green);
                        }
                        currentPosition = Intersection;
                        isFlying = false;
                    }
                    else
                    {
                        currentPosition.X += (float)(changex * Tile.SIZE);
                        currentPosition.Y += (float)(changey * Tile.SIZE);
                    }
                }
            }

            for (int dx = -5; dx <= 5; dx++)
            {
                for (int dy = -5; dy <= 5; dy++)
                {
                    int x = (int)(startingPosition.X / Tile.SIZE) + dx;
                    int y = (int)(startingPosition.Y / Tile.SIZE) + dy;
                    if (x >= 0 && y >= 0 && x < Map.fullWidth / Tile.SIZE && y < Map.TILEHEIGHT)
                    {
                        if (Math.Abs(dy) < 2 && Math.Abs(dx) < 2)
                        {
                            if (Math.Abs(dy) < 1 && Math.Abs(dx) < 1)
                            {
                                Map.getTile(new Point(x, y)).LightUpFogWhite = true;
                            }
                            Map.getTile(new Point(x, y)).LightUpFogRed = true;
                        }
                        Map.getTile(new Point(x, y)).LightUpFog = true;
                    }
                }
            }

            ProjectileManager.addLine(new Vector2[] { startingPosition, currentPosition }, stats.damageMax);
            ParticleStuff.addDirectionalFireEffect(angle, 15, startingPosition, 3, stats.damageMax / 3);
        }
    }

    public struct WeaponStats
    {
        public enum WeaponType : byte
        {
            Handgun = 0,
            Shotgun = 1,
            AR = 3,
            LongRifle = 4,
        }

        public static List<WeaponStats> AllStats;

        public static void LOAD_ALL_WEAPON_DATA()
        {
            AllStats = new List<WeaponStats>();
            FileReader fr = new FileReader("Content\\WeaponData.txt");
            string line = fr.readLine();
            while (line != "END_OF_DOCUMENT")
            {
                if (line.Length > 0 && line[0] != '#')
                {
                    if (line == "WEAPON")
                    {
                        AllStats.Add(new WeaponStats(fr, AllStats.Count));
                    }
                }
                line = fr.readLine();
            }
        }

        public int reloadTime;
        public int clipReloadTime;
        public int WeaponID;
        public string Name;
        public string description;

        public int numberOfProjectiles;
        public int multiprojectileDelay;

        public int damageMin;
        public int damageMax;
        public int weight;

        public int riccochet;
        public int setupTime;
        public double setupAccuracy;
        public int setupReload;
        public int setupClipReload;
        public bool reqiresSetup;

        public int startingAmmo;
        public int clipSize;
        public double accuracy;
        public int cost;
        public WeaponType type;
        public bool isAutomatic;

        public int SightRange;

        public WeaponStats(FileReader fr, int WID)
        {
            riccochet = 1;
            setupTime = 60;
            setupAccuracy = 0;
            setupReload = 60;
            setupClipReload = 60;
            SightRange = 50;
            cost = 10;
            isAutomatic = false;
            type = WeaponType.Handgun;
            reloadTime = 60;
            weight = 10;
            clipReloadTime = 60;
            WeaponID = WID;
            Name = "[No Name]";
            description = "[No Description]";
            numberOfProjectiles = 1;
            multiprojectileDelay = 0;
            damageMax = 1;
            damageMin = 1;
            startingAmmo = 10;
            clipSize = 10;
            accuracy = 0;
            reqiresSetup = false;

            string nextLine = fr.readLine();
            while (nextLine != "ENDWEAPON")
            {
                if (nextLine[0] != '#' && nextLine.Length != 0)
                {
                    string command = nextLine.Split(' ')[0].ToUpper();
                    string param = nextLine.Substring(nextLine.IndexOf(' ') + 1);
                    switch (command)
                    {
                        case "RELOADTIME": reloadTime = int.Parse(param); break;
                        case "CLIPRELOADTIME": clipReloadTime = int.Parse(param); break;
                        case "NAME": Name = param; break;
                        case "DESCRIPTION": description = param; break;
                        case "NUMBEROFPROJECTILES": numberOfProjectiles = int.Parse(param); break;
                        case "MULTIPROJECTILEDELAY": multiprojectileDelay = int.Parse(param); break;
                        case "DAMAGEMIN": damageMin = int.Parse(param); break;
                        case "DAMAGEMAX": damageMax = int.Parse(param); break;
                        case "STARTINGAMMO": startingAmmo = int.Parse(param); break;
                        case "CLIPSIZE": clipSize = int.Parse(param); break;
                        case "ACCURACY": accuracy = double.Parse(param); break;
                        case "WEIGHT": weight = int.Parse(param); break;
                        case "AUTOMATIC": isAutomatic = int.Parse(param) == 1; break;
                        case "TYPE": type = (WeaponType)byte.Parse(param); break;
                        case "COST": cost = int.Parse(param); break;
                        case "SIGHTRANGE": SightRange = int.Parse(param); break;
                        case "RICCOCHET": riccochet = int.Parse(param); break;
                        case "SETUPTIME": setupTime = int.Parse(param); break;
                        case "SETUPACCURACY": setupAccuracy = double.Parse(param); break;
                        case "SETUPRELOAD": setupReload = int.Parse(param); break;
                        case "SETUPCLIPRELOAD": setupClipReload = int.Parse(param); break;
                        case "REQUIRESSETUP": reqiresSetup = int.Parse(param) == 1; break;
                        default: Console.Out.WriteLine("Unrecognised Property \"" + command + "\" with param \"" + param + "\" on weapon " + WeaponID); break;
                    }
                }
                nextLine = fr.readLine();
            }
        }
    }
}﻿namespace NCodeRiddian
{
    public class ActivePath : Path
    {
        public static ActivePath MakeActive(Path p)
        {
            ActivePath np = new ActivePath();
            np.path = p.GetPath();
            np.currentlyReached = null;
            np.isPathDone = false;
            return np;
        }

        private Pathable currentlyReached;
        private bool isPathDone;

        /// <summary>
        /// Gets the pathable currently moving to
        /// </summary>
        /// <returns></returns>
        public Pathable getNext()
        {
            if (isPathDone)
                return base.getLast();
            if (currentlyReached == null)
                return getFirst();
            else
                return getNext(currentlyReached);
        }

        /// <summary>
        /// The next pathable was reached - advance the path
        /// </summary>
        public void reachedNext()
        {
            if (isPathDone)
                return;
            if (currentlyReached == null)
                currentlyReached = getFirst();
            if (currentlyReached == base.getLast())
                isPathDone = true;
            else
                currentlyReached = base.getNext(currentlyReached);
        }

        /// <summary>
        /// The specified pathable was reached - advance the path
        /// </summary>
        /// <param name="p"></param>
        public void reached(Pathable p)
        {
            if (isPathDone)
                return;
            if (p == base.getLast())
                isPathDone = true;
            else
                currentlyReached = base.getNext(p);
        }

        /// <summary>
        /// Is this path finished?
        /// </summary>
        /// <returns></returns>
        public bool amDone()
        {
            return isPathDone;
        }
    }
}﻿namespace NCodeRiddian
{
    public static class ArrayManager
    {
        public delegate void UseItem<E>(E item, params int[] pos);

        public delegate void UseItemSimple<E>(E item, int x, int y);

        public static void ForAll<E>(E[,] array, UseItem<E> function)
        {
            for (int x = 0; x < array.GetLength(0); x++)
            {
                for (int y = 0; y < array.GetLength(1); y++)
                {
                    function(array[x, y], x, y);
                }
            }
        }

        public static void ForAll<E>(E[,] array, UseItemSimple<E> function)
        {
            for (int x = 0; x < array.GetLength(0); x++)
            {
                for (int y = 0; y < array.GetLength(1); y++)
                {
                    function(array[x, y], x, y);
                }
            }
        }

        public static void ForAll<E>(E[, ,] array, UseItem<E> function)
        {
            for (int x = 0; x < array.GetLength(0); x++)
            {
                for (int y = 0; y < array.GetLength(1); y++)
                {
                    for (int z = 0; z < array.GetLength(2); z++)
                        function(array[x, y, z], x, y, z);
                }
            }
        }

        public static void ForAll<E>(E[] array, UseItem<E> function)
        {
            for (int x = 0; x < array.GetLength(0); x++)
            {
                function(array[x], x);
            }
        }
    }
}﻿using System;
using System.Collections.Generic;
using Microsoft.Xna.Framework;

namespace NCodeRiddian
{
    public abstract class ArrayPather
    {
        private class PathNode : IComparable
        {
            public float hscore;
            public float fscore;
            public PathNode parent;
            public Point cell;
            public bool closed;

            public PathNode(PathNode pt, Point c, Point end)
            {
                cell = c;
                parent = pt;
                hscore = PointM.Sum(PointM.Add(end, -c.X, -c.Y));
                closed = false;
            }

            public GenericPath GeneratePath()
            {
                GenericPath gp = new GenericPath();
                return _GeneratePath(gp);
            }

            public GenericPath _GeneratePath(GenericPath gp)
            {
                gp.Add(cell);
                if (parent != null)
                    return parent._GeneratePath(gp);
                return gp;
            }

            public int CompareTo(object obj)
            {
                PathNode other = (PathNode)obj;
                return (int)((hscore + fscore) - (other.hscore + other.fscore));
            }
        }

        public static Point[] increments = new Point[] { new Point(1, 0), new Point(-1, 0), new Point(0, 1), new Point(0, -1) };
        public static Point[] dincrements = new Point[] { new Point(1, 0), new Point(-1, 0), new Point(0, 1), new Point(0, -1), new Point(1, 1), new Point(1, -1), new Point(-1, 1), new Point(-1, -1) };

        public static GenericPath GeneratePath<E>(E[,] arr, Point start, Point end, Func<Point, Point, bool> isPathable, Func<E, E, Point, Point, float> GetFScore, bool diagonal)
        {
            PathNode[,] nodes = new PathNode[arr.GetLength(0), arr.GetLength(1)];
            MinHeap<PathNode> openHeap = new MinHeap<PathNode>(Comparer<PathNode>.Default);
            nodes[start.X, start.Y] = new PathNode(null, start, end);
            nodes[start.X, start.Y].fscore = 0;
            openHeap.Add(nodes[start.X, start.Y]);
            bool done = false;
            do
            {
                PathNode current = openHeap.ExtractDominating();
                foreach (Point p in diagonal ? dincrements : increments)
                {
                    Point next = PointM.Add(current.cell, p.X, p.Y);
                    if (PointM.Assure(next, 0, arr.GetLength(0), 0, arr.GetLength(1)))
                    {
                        if (isPathable(current.cell, next))
                        {
                            float tfscore = current.fscore + GetFScore(arr[current.cell.X, current.cell.Y], arr[next.X, next.Y], current.cell, next);
                            if ((nodes[next.X, next.Y] != null && (!nodes[next.X, next.Y].closed && nodes[next.X, next.Y].fscore > tfscore)) || nodes[next.X, next.Y] == null)
                            {
                                nodes[next.X, next.Y] = new PathNode(current, next, end);
                                nodes[next.X, next.Y].fscore = tfscore;
                                openHeap.Add(nodes[next.X, next.Y]);
                                if (next.Equals(end))
                                    done = true;
                            }
                        }
                    }
                }
            } while (!done && openHeap.Count > 0);
            if (openHeap.Count != 0)
                return nodes[end.X, end.Y].GeneratePath();
            return null;
        }
    }

    public class GenericPath : A_Path<Point>
    {
        public GenericPath()
            : base()
        {
        }

        public GenericPath(List<Point> Path)
            : base(Path)
        {
        }

        public GenericPath Reverse()
        {
            List<Point> npath = new List<Point>();
            for (int x = path.Count - 1; x > 0; x--)
                npath.Add(path[x]);
            return new GenericPath(npath);
        }

        public override bool isValid(Point t)
        {
            return true;
        }
    }
}﻿using System.Collections.Generic;

namespace NCodeRiddian
{
    public class Association<E, E2>
    {
        private List<E> keys;
        private List<E2> values;

        public Association()
        {
            keys = new List<E>();
            values = new List<E2>();
        }

        public E2 this[E e]
        {
            get
            {
                int i = keys.IndexOf(e);
                if (i == -1)
                    return default(E2);
                return values[keys.IndexOf(e)];
            }
            set
            {
                values[keys.IndexOf(e)] = value;
            }
        }

        public void Add(E key, E2 value)
        {
            keys.Add(key);
            values.Add(value);
        }

        public void Remove(E key)
        {
            values.RemoveAt(keys.IndexOf(key));
            keys.Remove(key);
        }
    }
}﻿using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;

namespace NCodeRiddian
{
    public class BinarySearchTree <E> : IEnumerable<E>
    {
        List<TreeNode<E>> tree;
        Comparer<E> DefaultComparer;

        public BinarySearchTree(Comparer<E> DefaultComparer)
        {
            tree = new List<TreeNode<E>>();
            this.DefaultComparer = DefaultComparer;
        }

        public BinarySearchTree():this(Comparer<E>.Default)
        {
        }

        public void SetDefaultComparer(Comparer<E> NewComparer)
        {
            DefaultComparer = NewComparer;
        }

        public int Count()
        {
            return tree.Count;
        }

        public void Add(E item, Comparer<E> comp)
        {
            if (tree.Count == 0)
            {
                tree.Add(new TreeNode<E>(item, null));
            }
            else
                tree[0].AddNode(item, comp);
        }

        public void Add(E item)
        {
            Add(item, DefaultComparer);
        }

        public E Find(E compareTo, Comparer<E> compare)
        {
            return tree[0].SearchFor(compareTo, compare);
        }

        public List<E> SortedArray()
        {
            return tree[0].GetSortedList(new List<E>());
        }

        public IEnumerator<E> GetEnumerator()
        {
            return (IEnumerator<E>)tree.Take(tree.Count).GetEnumerator();
        }

        System.Collections.IEnumerator System.Collections.IEnumerable.GetEnumerator()
        {
            return tree.GetEnumerator();
        }
    }

    public class TreeNode<E>
    {
        E myNode;
        int Count;
        TreeNode<E> Parent;
        TreeNode<E> LeftChild;
        TreeNode<E> RightChild;

        public static implicit operator E(TreeNode<E> tn)
        {
            return tn.GetElement();
        }

        public TreeNode(E elem, TreeNode<E> parent)
        {
            myNode = elem;
            LeftChild = null;
            RightChild = null;
            Parent = parent;
            Count = 0;
        }

        public E GetElement()
        {
            return myNode;
        }

        public List<E> GetSortedList(List<E> cur)
        {
            if (LeftChild != null)
                LeftChild.GetSortedList(cur);
            cur.Add(GetElement());
            if (RightChild != null)
                RightChild.GetSortedList(cur);
            return cur;
        }

        public void AddNode(E n, Comparer<E> comp)
        {
            Count++;
            if (comp.Compare(myNode, n) < 0)
            {
                if (RightChild == null)
                    RightChild = new TreeNode<E>(n, this);
                else
                    RightChild.AddNode(n, comp);
            }
            else
            {
                if (LeftChild == null)
                    LeftChild = new TreeNode<E>(n, this);
                else
                    LeftChild.AddNode(n, comp);
            }
        }

        public TreeNode<E> SearchFor(E n, Comparer<E> comp)
        {
            var v = comp.Compare(myNode, n);
            if (v == 0)
                return this;
            if (v < 0)
            {
                if (RightChild == null)
                    return null;
                return RightChild.SearchFor(n, comp);
            }
            else
            {
                if (LeftChild == null)
                    return null;
                return LeftChild.SearchFor(n, comp);
            }
        }

        private void TreeUpDecrimentCount()
        {
            Count--;
            if (Parent != null)
                Parent.TreeUpDecrimentCount();
        }

    }
}
﻿using System;
using Microsoft.Xna.Framework;
using Microsoft.Xna.Framework.Graphics;

namespace NCodeRiddian
{
    public abstract class Camera
    {
        private static Rectangle cameraLocation;
        private static float zoom;
        private static Point origin;

        private static Texture2D spix;
        private static GraphicsDevice gd;

        public static void setupGenericTexture(GraphicsDevice gd)
        {
            Camera.gd = gd;
            spix = new Texture2D(gd, 1, 1);
            spix.SetData<Color>(new Color[] { Color.White });
        }

        public static void setupCamera(Point camSize)
        {
            setupCamera(camSize, new Point(0, 0));
        }

        public static void setupCamera(Point camSize, Point origin)
        {
            cameraLocation = new Rectangle(0, 0, camSize.X, camSize.Y);
            zoom = 1;
            Camera.origin = origin;
        }

        public static Point getOrigin()
        {
            return origin;
        }

        public static Rectangle getCamera()
        {
            return cameraLocation;
        }

        public static void addX(int x)
        {
            cameraLocation.X += x;
        }

        public static void addY(int y)
        {
            cameraLocation.Y += y;
        }

        public static void incrementCamera(Point p)
        {
            cameraLocation.X += p.X;
            cameraLocation.Y += p.Y;
        }

        /// <summary>
        /// Get camera location (Not including Scaling)
        /// Use getFullCamera for scaling included.
        /// </summary>
        /// <returns></returns>
        public static Rectangle getlocation()
        {
            return cameraLocation;
        }

        /// <summary>
        /// Set camera location
        /// </summary>
        /// <param name="p"></param>
        public static void setLocation(Point p)
        {
            cameraLocation.Location = p;
        }

        /// <summary>
        /// Center the camera on this point
        /// </summary>
        /// <param name="v"> Point on which to center </param>
        public static void Center(Vector2 v)
        {
            Point p = new Point((int)Math.Round(v.X), (int)Math.Round(v.Y));
            Center(p);
        }

        /// <summary>
        /// Center the camera on this point
        /// </summary>
        /// <param name="p"> Point on which to center </param>
        public static void Center(Point p)
        {
            cameraLocation.X = p.X - (getFullScreen().Width / 2);
            cameraLocation.Y = p.Y - (getFullScreen().Height / 2);
        }

        /// <summary>
        /// Zoom by an ammount, focusing on the center.
        /// </summary>
        /// <param name="amt">The ammount by which to zoom</param>
        public static void Zoom(float amt)
        {
            Point zoomCenter = new Point(getFullScreen().X + (getFullScreen().Width / 2), getFullScreen().Y + (getFullScreen().Height / 2));

            //TODO Zoom to center of Camera.
            zoom += amt;
            setLocation(new Point(zoomCenter.X - (int)(getFullScreen().Width / 2f), zoomCenter.Y - (int)(getFullScreen().Height / 2f)));
        }

        /// <summary>
        /// Zooms the camera to a specified zoom value.
        /// </summary>
        /// <param name="amt">The value to zoom to</param>
        public static void ZoomTo(float amt)
        {
            Zoom(amt - zoom);
        }

        /// <summary>
        /// Get current zoom level
        /// </summary>
        /// <returns>Zoom level</returns>
        public static float getZoom()
        {
            return zoom;
        }

        /// <summary>
        /// Get the full area of the screen.
        /// </summary>
        /// <returns> Rectangle full area of the screen</returns>
        public static Rectangle getFullScreen()
        {
            return new Rectangle(cameraLocation.X, cameraLocation.Y, (int)Math.Ceiling(cameraLocation.Width / zoom), (int)Math.Ceiling(cameraLocation.Height / zoom));
        }

        /// <summary>
        /// Assures this camera is within these bounds.
        /// </summary>
        /// <param name="r"> Maximum camera bounds</param>
        public static void assure(Rectangle r)
        {
            if (cameraLocation.X < r.X)
            {
                cameraLocation.X = r.X;
            }
            if (cameraLocation.Y < r.Y)
            {
                cameraLocation.Y = r.Y;
            }
            if (cameraLocation.X + Math.Round(cameraLocation.Width / zoom) > r.X + r.Width)
                cameraLocation.X = (int)Math.Round(r.X + r.Width - (cameraLocation.Width / zoom));

            if (cameraLocation.Y + Math.Round(cameraLocation.Height / zoom) > r.Y + r.Height)
                cameraLocation.Y = (int)Math.Round(r.Y + r.Height - (cameraLocation.Height / zoom));
        }

        public static void draw(SpriteBatch sb, Image image, Rectangle r)
        {
            draw(sb, image, r, Color.White, null, 0, Vector2.Zero, SpriteEffects.None, 0);
        }

        public static void draw(SpriteBatch sb, Image image, Rectangle r, Color c)
        {
            draw(sb, image, r, c, null, 0, Vector2.Zero, SpriteEffects.None, 0);
        }

        public static void draw(SpriteBatch sb, Image image, Color c, Rectangle r, float rotation, Vector2 origin)
        {
            draw(sb, image, r, c, null, rotation, origin, SpriteEffects.None, 0);
        }

        public static Texture2D getGeneric()
        {
            return spix;
        }

        /// <summary>
        /// Draws an image to the screen using this camera.
        /// </summary>
        /// <param name="sb"> The Sprite Batch </param>
        /// <param name="image"> The Image </param>
        /// <param name="r"> The image location and size</param>
        /// <param name="c"> Color tinting</param>
        /// <param name="sourceRectangle"> Source of image, use Null for animated Image</param>
        /// <param name="rotation"> Rotation of image </param>
        /// <param name="origin"> Origin of image </param>
        /// <param name="effects"> sprite effect for image</param>
        /// <param name="layerDepth"> Layerdepth of image</param>
        public static void draw(SpriteBatch sb, Image image, Rectangle r, Color c, Rectangle? sourceRectangle, float rotation, Vector2 origin, SpriteEffects effects, int layerDepth)
        {
            r.X -= (int)Math.Round(origin.X);
            r.Y -= (int)Math.Round(origin.Y);
            if (getFullScreen().Intersects(r))
            {
                r.X += (int)Math.Round(origin.X);
                r.Y += (int)Math.Round(origin.Y);
                sb.Draw(image.getTexture(),
                        new Rectangle(
                            (int)((Math.Floor((r.X - cameraLocation.X) * zoom)) + Camera.origin.X),
                            (int)((Math.Floor((r.Y - cameraLocation.Y) * zoom)) + Camera.origin.Y),
                            (int)Math.Ceiling(r.Width * zoom),
                            (int)Math.Ceiling(r.Height * zoom)),
                            sourceRectangle == null && image is AnimatedImage ? ((AnimatedImage)image).getFrame() : sourceRectangle,
                            c, rotation, origin, effects, layerDepth);
            }
        }

        public static void drawNoCheck(SpriteBatch sb, Image image, Rectangle r, Color c, Rectangle? sourceRectangle, float rotation, Vector2 origin, SpriteEffects effects, int layerDepth)
        {
            sb.Draw(image.getTexture(),
                    new Rectangle(
                        (int)((Math.Floor((r.X - cameraLocation.X) * zoom)) + Camera.origin.X),
                        (int)((Math.Floor((r.Y - cameraLocation.Y) * zoom)) + Camera.origin.Y),
                        (int)Math.Ceiling(r.Width * zoom),
                        (int)Math.Ceiling(r.Height * zoom)),
                        sourceRectangle == null && image is AnimatedImage ? ((AnimatedImage)image).getFrame() : sourceRectangle,
                        c, rotation, origin, effects, layerDepth);
        }

        public static void drawGeneric(SpriteBatch sb, Rectangle r, Color c, Rectangle? sourceRectangle, float rotation, Vector2 origin, SpriteEffects effects, int layerDepth)
        {
            r.X -= (int)Math.Round(origin.X);
            r.Y -= (int)Math.Round(origin.Y);
            if (getFullScreen().Intersects(r))
            {
                r.X += (int)Math.Round(origin.X);
                r.Y += (int)Math.Round(origin.Y);
                sb.Draw(spix,
                        new Rectangle(
                            (int)((Math.Floor((r.X - cameraLocation.X) * zoom)) + Camera.origin.X),
                            (int)((Math.Floor((r.Y - cameraLocation.Y) * zoom)) + Camera.origin.Y),
                            (int)Math.Ceiling(r.Width * zoom),
                            (int)Math.Ceiling(r.Height * zoom)),
                            sourceRectangle,
                            c, rotation, origin, effects, layerDepth);
            }
        }

        public static void drawGeneric(SpriteBatch sb, Rectangle r, Color c)
        {
            if (getFullScreen().Intersects(r))
            {
                sb.Draw(spix,
                        new Rectangle(
                            (int)((Math.Floor((r.X - cameraLocation.X) * zoom)) + Camera.origin.X),
                            (int)((Math.Floor((r.Y - cameraLocation.Y) * zoom)) + Camera.origin.Y),
                            (int)Math.Ceiling(r.Width * zoom),
                            (int)Math.Ceiling(r.Height * zoom)),
                            null,
                            c, 0, Vector2.Zero, SpriteEffects.None, 0);
            }
        }

        public static void drawGenericPlusTransparency(SpriteBatch sb, Rectangle r, Color c, Rectangle? sourceRectangle, float rotation, Vector2 origin, SpriteEffects effects, int layerDepth)
        {
            Texture2D spix = new Texture2D(gd, 1, 1);
            spix.SetData<Color>(new Color[] { c });
            r.X -= (int)Math.Round(origin.X);
            r.Y -= (int)Math.Round(origin.Y);
            if (getFullScreen().Intersects(r))
            {
                r.X += (int)Math.Round(origin.X);
                r.Y += (int)Math.Round(origin.Y);
                sb.Draw(spix,
                        new Rectangle(
                            (int)((Math.Floor((r.X - cameraLocation.X) * zoom)) + Camera.origin.X),
                            (int)((Math.Floor((r.Y - cameraLocation.Y) * zoom)) + Camera.origin.Y),
                            (int)Math.Ceiling(r.Width * zoom),
                            (int)Math.Ceiling(r.Height * zoom)),
                            sourceRectangle,
                            Color.White, rotation, origin, effects, layerDepth);
            }
        }

        public static void drawGenericNoCheck(SpriteBatch sb, Rectangle r, Color c, Rectangle? sourceRectangle, float rotation, Vector2 origin, SpriteEffects effects, int layerDepth)
        {
            sb.Draw(spix,
                    new Rectangle(
                        (int)((Math.Floor((r.X - cameraLocation.X) * zoom)) + Camera.origin.X),
                        (int)((Math.Floor((r.Y - cameraLocation.Y) * zoom)) + Camera.origin.Y),
                        (int)Math.Ceiling(r.Width * zoom),
                        (int)Math.Ceiling(r.Height * zoom)),
                        sourceRectangle,
                        c, rotation, origin, effects, layerDepth);
        }

        public static void drawAsLine(SpriteBatch sb, Image i, Vector2 p1, Vector2 p2, int forcedWidth, Color c)
        {
            float distance = LocationManager.getDistance(p1, p2);
            float rotation = LocationManager.getRotation(p1, p2);

            Vector2 placementPoint = LocationManager.moveByRotation(p1, distance / 2, rotation);

            Rectangle colisCheck = new Rectangle((int)Math.Ceiling(Math.Min(p1.X, p2.X)), (int)Math.Ceiling(Math.Min(p1.Y, p2.Y)), (int)Math.Ceiling(Math.Abs(p1.X - p2.X)), (int)Math.Ceiling(Math.Abs(p1.Y - p2.Y)));

            Rectangle drawLocation = new Rectangle((int)placementPoint.X, (int)placementPoint.Y, (int)Math.Ceiling(distance), forcedWidth);

            drawLocation = new Rectangle(
                            (int)((Math.Round((drawLocation.X - cameraLocation.X) * zoom)) + Camera.origin.X),
                            (int)((Math.Round((drawLocation.Y - cameraLocation.Y) * zoom)) + Camera.origin.Y),
                            (int)Math.Round(drawLocation.Width * zoom),
                            (int)Math.Round(drawLocation.Height * zoom));

            if (colisCheck.Intersects(getFullScreen()))
                sb.Draw(i.getTexture(), drawLocation, null, c, rotation, new Vector2(((float)i.getTexture().Width) / 2f, ((float)i.getTexture().Height) / 2f), SpriteEffects.None, 0);
        }

        public static void drawString(SpriteBatch sb, SpriteFont sf, string text, Vector2 location, Color c, float rot, Vector2 origin, SpriteEffects seffect, int layerDep)
        {
            Rectangle stringmeasure = new Rectangle((int)Math.Round(location.X), (int)Math.Round(location.Y), (int)Math.Round(sf.MeasureString(text).X), (int)Math.Round(sf.MeasureString(text).Y));

            stringmeasure.X -= (int)Math.Round(origin.X);
            stringmeasure.Y -= (int)Math.Round(origin.Y);

            if (stringmeasure.Intersects(getFullScreen()))
            {
                stringmeasure.X += (int)Math.Round(origin.X);
                stringmeasure.Y += (int)Math.Round(origin.Y);
                sb.DrawString(sf, text, new Vector2(((location.X - cameraLocation.X) * zoom) + Camera.origin.X, ((location.Y - cameraLocation.Y) * zoom) + Camera.origin.Y), c, rot, origin, zoom, seffect, layerDep);
            }
        }

        public static void drawLineGeneric(Vector2 v1, Vector2 v2, SpriteBatch sb, Color c, int width)
        {
            float betweenAngle = LocationManager.getRotation(v1, v2);
            float distance = LocationManager.getDistance(v1, v2);
            drawGenericNoCheck(sb, new Rectangle((int)Math.Round(LocationManager.moveByRotation(v1, distance / 2f, betweenAngle).X), (int)Math.Round(LocationManager.moveByRotation(v1, distance / 2f, betweenAngle).Y), (int)Math.Round(distance), width), c, null, betweenAngle, new Vector2(0.5f, 0.5f), SpriteEffects.None, 0);
        }

        public static void drawLineGeneric(Vector2 v1, Vector2 v2, SpriteBatch sb, Color c)
        {
            float betweenAngle = LocationManager.getRotation(v1, v2);
            float distance = LocationManager.getDistance(v1, v2);
            drawGenericNoCheck(sb, new Rectangle((int)Math.Round(LocationManager.moveByRotation(v1, distance / 2f, betweenAngle).X), (int)Math.Round(LocationManager.moveByRotation(v1, distance / 2f, betweenAngle).Y), (int)Math.Round(distance), 1), c, null, betweenAngle, new Vector2(0.5f, 0.5f), SpriteEffects.None, 0);
        }

        public static void drawStringNoZoom(SpriteBatch sb, SpriteFont sf, string text, Vector2 location, Color c, float rot, Vector2 origin, SpriteEffects seffect, int layerDep)
        {
            Rectangle stringmeasure = new Rectangle((int)Math.Round(location.X), (int)Math.Round(location.Y), (int)Math.Round(sf.MeasureString(text).X), (int)Math.Round(sf.MeasureString(text).Y));

            stringmeasure.X -= (int)Math.Round(origin.X);
            stringmeasure.Y -= (int)Math.Round(origin.Y);

            if (stringmeasure.Intersects(getFullScreen()))
            {
                stringmeasure.X += (int)Math.Round(origin.X);
                stringmeasure.Y += (int)Math.Round(origin.Y);
                sb.DrawString(sf, text, new Vector2(((location.X - cameraLocation.X) * zoom) + Camera.origin.X, ((location.Y - cameraLocation.Y) * zoom) + Camera.origin.Y), c, rot, origin, 1, seffect, layerDep);
            }
        }

        public static void drawWrappedText(SpriteBatch sb, WrappedText tex, Point p, float spacing, Color c)
        {
            Rectangle measure = new Rectangle(p.X, p.Y, tex.getWidth(), (int)tex.getHeight(spacing));

            if (measure.Intersects(getFullScreen()))
            {
                tex.draw(sb, new Vector2(((p.X - cameraLocation.X) * zoom) + Camera.origin.X, ((p.Y - cameraLocation.Y) * zoom) + Camera.origin.Y), spacing, c);
            }
        }
    }
}﻿using System;
using Microsoft.Xna.Framework;
using Microsoft.Xna.Framework.Input;

namespace NCodeRiddian
{
    public abstract class Cursor
    {
        public static bool leftDown = false;
        public static bool rightDown = false;
        public static bool leftPress = false;
        public static bool rightPress = false;
        private static int lastWheel;
        private static int thisWheel;
        private static MouseState previousState = Mouse.GetState();
        private static MouseState currentState = Mouse.GetState();

        public static void update()
        {
            previousState = currentState;
            currentState = Mouse.GetState();

            lastWheel = thisWheel;
            thisWheel = Mouse.GetState().ScrollWheelValue;

            /*
            if (Mouse.GetState().LeftButton == ButtonState.Pressed)
            {
                if (leftDown)
                    leftPress = false;
                else
                {
                    leftPress = true;
                    leftDown = true;
                }
            }
            else
            {
                leftDown = false;
            }

            if (Mouse.GetState().RightButton == ButtonState.Pressed)
            {
                if (rightDown)
                    rightPress = false;
                else
                {
                    rightPress = true;
                    rightDown = true;
                }
            }
            else
            {
                rightDown = false;
            }*/

            leftDown = currentState.LeftButton == ButtonState.Pressed;
            rightDown = currentState.RightButton == ButtonState.Pressed;

            leftPress = currentState.LeftButton == ButtonState.Pressed && previousState.LeftButton == ButtonState.Released;
            rightPress = currentState.RightButton == ButtonState.Pressed && previousState.RightButton == ButtonState.Released;
        }

        public static int getMouseWheel()
        {
            return Mouse.GetState().ScrollWheelValue;
        }

        public static int getCurrentMouseWheel()
        {
            return thisWheel - lastWheel;
        }

        public static Point screenLoc()
        {
            return new Point(Mouse.GetState().X, Mouse.GetState().Y);
        }

        public static Point worldLoc()
        {
            return new Point(Camera.getlocation().X + ((int)Math.Round(((float)Mouse.GetState().X - (float)Camera.getOrigin().X) / Camera.getZoom())), Camera.getlocation().Y + ((int)Math.Round(((float)Mouse.GetState().Y - (float)Camera.getOrigin().Y) / Camera.getZoom())));
        }
    }
}﻿using System;
using System.IO;

namespace NCodeRiddian
{
    public class FileReader
    {
        private StreamReader read;

        public FileReader(string fileloc)
        {
            try
            {
                read = new StreamReader(fileloc);
            }
            catch (DirectoryNotFoundException e)
            {
                try
                {
                    read = new StreamReader("Content/" + fileloc);
                }
                catch (DirectoryNotFoundException e2)
                {
                    throw e2;
                }
            }
        }

        public char readNextChar()
        {
            return (char)read.Read();
        }

        public string readNext()
        {
            string outString = "";
            if (read.Peek() < 0 || read.EndOfStream)
                return null;
            char nextChar = readNextChar();
            while (nextChar != ' ' && nextChar != '\n' && nextChar != '\r')
            {
                outString += nextChar;
                nextChar = readNextChar();
                if (read.EndOfStream)
                    return outString;
            }
            if (nextChar == '\n' || nextChar == '\r')
                readNextChar();
            return outString;
        }

        public string readLine()
        {
            return read.ReadLine();
        }

        public bool hasNext()
        {
            return !read.EndOfStream;
        }

        public int readInt()
        {
            return Int32.Parse(readNext());
        }

        public double readDouble()
        {
            return Double.Parse(readNext());
        }

        public float readFloat()
        {
            return float.Parse(readNext());
        }
    }
}﻿using System;
using Microsoft.Xna.Framework;

namespace NCodeRiddian
{
    public class FOV
    {
        #region oldFOV

        /*
        static Point[] MainDirections = {new Point(1, 0),       // Issue if < 0 ???
                                         new Point(0, -1),
                                         new Point(0, -1),
                                         new Point(-1, 0),
                                         new Point(-1, 0),
                                         new Point(0, 1),
                                         new Point(0, 1),
                                         new Point(1, 0),
                                        };
        static Point[] SubDirections = {new Point(0, -1),
                                  new Point(1, 0),
                                  new Point(-1, 0),
                                  new Point(0, -1),
                                  new Point(0, 1),
                                  new Point(-1, 0),
                                  new Point(1, 0),
                                  new Point(0, 1),
                                 };
        static Point[] TargetAngles = { new Point(1, -1), new Point(-1, -1), new Point(-1, 1), new Point(1, 1) };
        static Point[] getMax = { new Point(1, 1), //0
                                  new Point(0, 0), //1
                                  new Point(1, 0), //2
                                  new Point(0, 1), //3
                                  new Point(0, 0), //4
                                  new Point(1, 1), //5
                                  new Point(0, 1),
                                  new Point(1, 0) };
        static Point[] getMin = { new Point(0,0), //0
                                  new Point(1,1), //1
                                  new Point(0, 1), //2
                                  new Point(1, 0), //3
                                  new Point(1, 1), //4
                                  new Point(0, 0), //5
                                  new Point(1, 0),
                                  new Point(0, 1) };

        public static void Calculate(Point Source, I_Seeable[,] World, int range)
        {
            World[Source.X, Source.Y].see(1);
            for (int Q = 0; Q < 8; Q++)
            {
                FOVHelper(Source, World, Q, MainDirections[Q], TargetAngles[Q / 2], 1, range);
            }
        }

        private static void FOVHelper(Point source, I_Seeable[,] World, int quad, Point minAngle, Point maxAngle, int distance, int sightRange)
        {
            Point MainDirection = MainDirections[quad];
            Point SubDirection = SubDirections[quad];
            Point Current = new Point( source.X + (MainDirection.X * distance) + Math.Abs(SubDirection.X) * (minAngle.Y == 0 ? 0 : (distance * minAngle.X) / minAngle.Y),
                                       source.Y + (MainDirection.Y * distance) + Math.Abs(SubDirection.Y) * (minAngle.X == 0 ? 0 : (distance * minAngle.Y) / minAngle.X));
            Point Target = new Point(  source.X + (MainDirection.X * distance) + Math.Abs(SubDirection.X) * (maxAngle.Y == 0 ? 0 : (distance * maxAngle.X) / maxAngle.Y),
                                       source.Y + (MainDirection.Y * distance) + Math.Abs(SubDirection.Y) * (maxAngle.X == 0 ? 0 : (distance * maxAngle.Y) / maxAngle.X));
            SubDirection = new Point(Math.Sign(Target.X - Current.X), Math.Sign(Target.Y - Current.Y));
            //if (distance == 1)
              //  Console.Out.WriteLine("Quad {0}, SUB {1}, DIR {2}, ANGLE {3}-{4}", quad, new Point(Target.X - Current.X, Target.Y - Current.Y), SubDirection, minAngle, maxAngle);
            Point newMin = minAngle;
            bool hasSeenOpen = false;
            int cur = 0;
            while (!Current.Equals(Target) && Current.X >= 0 && Current.X < World.GetLength(0) && Current.Y >= 0 && Current.Y < World.GetLength(1))
            {
                I_Seeable CurrentSeeable = World[Current.X, Current.Y];

                CurrentSeeable.see(1);

                CurrentSeeable.debug("" + cur);
                if (CurrentSeeable.isSightBlocking())
                {
                    if (hasSeenOpen && distance < sightRange)
                    {
                        hasSeenOpen = false;
                        Point newMax = new Point(Current.X - source.X + getMax[quad].X, Current.Y - source.Y - getMax[quad].Y);
                        CurrentSeeable.debug("" + newMax.X + "/" + newMax.Y);
                        FOVHelper(source, World, quad, newMin, newMax, distance + 1, sightRange);
                        newMin.X = Current.X - source.X + getMin[quad].X;
                        newMin.Y = Current.Y - source.Y + getMin[quad].Y;
                    }
                    else
                    {
                        newMin.X = Current.X - source.X + getMin[quad].X;
                        newMin.Y = Current.Y - source.Y + getMin[quad].Y;
                        CurrentSeeable.debug("" + newMin.X + "/" + newMin.Y);
                    }
                }
                else
                {
                    hasSeenOpen = true;
                }
                cur++;
                Current.X += SubDirection.X;
                Current.Y += SubDirection.Y;
            }

            if (hasSeenOpen && distance < sightRange)
            {
                FOVHelper(source, World, quad, newMin, maxAngle, distance + 1, sightRange);
            }
        }

        public static void CalculateSimple(Vector2 Source, I_Seeable[,] World, int range)
        {
        }
        */

        #endregion oldFOV

        #region NewFOV

        //  Octant data
        //
        //    \ 1 | 2 /
        //   8 \  |  / 3
        //   -----+-----
        //   7 /  |  \ 4
        //    / 6 | 5 \
        //
        //  1 = NNW, 2 =NNE, 3=ENE, 4=ESE, 5=SSE, 6=SSW, 7=WSW, 8 = WNW
        private static int[] VisibleOctants = { 1, 2, 3, 4, 5, 6, 7, 8 };

        /// <summary>
        /// Start here: go through all the octants which surround the player to
        /// determine which open cells are visible
        /// </summary>
        public static void Calculate(Point Source, I_Seeable[,] World, int range)
        {
            foreach (int o in VisibleOctants)
            {
                ScanOctant(Source, World, 1, o, 1.0, 0.0, range);
                //ScanOctantCompact(Source, World, 1, o, 1, 0, range);
            }
        }

        public static bool[,] GetSightMap(Point Source, I_Seeable[,] World, int range)
        {
            bool[,] ret = new bool[World.GetLength(0), World.GetLength(1)];
            bool[,] worldCol = new bool[World.GetLength(0), World.GetLength(1)];
            ArrayManager.ForAll<bool>(ret, (x, y) => x = false);
            ArrayManager.ForAll<bool>(worldCol, (x, y) => x = World[y[0], y[1]].isSightBlocking());
            foreach (int o in VisibleOctants)
            {
                ret = ScanOctant(Source, worldCol, ret, 1, o, 1.0, 0.0, range);
                //ScanOctantCompact(Source, World, 1, o, 1, 0, range);
            }

            return ret;
        }

        public static bool[,] GetSightMap(Point Source, bool[,] World, int range)
        {
            bool[,] ret = new bool[World.GetLength(0), World.GetLength(1)];

            ArrayManager.ForAll<bool>(ret, (x, y) => x = false);

            foreach (int o in VisibleOctants)
            {
                ret = ScanOctant(Source, World, ret, 1, o, 1.0, 0.0, range);
                //ScanOctantCompact(Source, World, 1, o, 1, 0, range);
            }

            return ret;
        }

        /*

        static Point[] MainMotion = { new Point(0, -1),
                                      new Point(0, -1),
                                      new Point(1, 0),
                                      new Point(1, 0),
                                      new Point(0, 1),
                                      new Point(0, 1),
                                      new Point(-1, 0),
                                      new Point(-1, 0)};
        static Point[] SubMotion = { new Point(-1, 0),
                                      new Point(1, 0),
                                      new Point(0, -1),
                                      new Point(0, 1),
                                      new Point(1, 0),
                                      new Point(-1, 0),
                                      new Point(0, 1),
                                      new Point(0, -1)};

        static bool[] CompareGT = { true, false, false, true, true, false, false, true };

        protected static void ScanOctantCompact(Point Source, I_Seeable[,] World, int pDepth, int pOctant, double pStartSlope, double pEndSlope, int range)
        {
            int x = 0, y = 0;
            Point MainMove = MainMotion[pOctant - 1];
            Point SubMove = SubMotion[pOctant - 1];
            bool mainX = true;
            int sub = 1;
            int main = 1;
            if (MainMove.X != 0)
            {
                x = Source.X + pDepth * MainMove.X;
                main = MainMove.X;
                x = Math.Max(0, Math.Min(World.GetLength(0), x));
                sub = SubMove.Y;
                y = Source.Y + SubMove.Y * Convert.ToInt32((pStartSlope * Convert.ToDouble(pDepth)));
                mainX = true;
            }
            else if (MainMove.Y != 0)
            {
                mainX = false;
                main = MainMove.Y;
                y = Source.Y + pDepth * MainMove.Y;
                y = Math.Max(0, Math.Min(World.GetLength(1), y));
                sub = SubMove.X;
                x = Source.X + SubMove.X * Convert.ToInt32((pStartSlope * Convert.ToDouble(pDepth)));
            }
            bool cgt = CompareGT[pOctant - 1];
            while((cgt && GetSlope(x, y, Source.X, Source.Y, !mainX) >= pEndSlope) ||
                  (!cgt && GetSlope(x, y, Source.X, Source.Y, !mainX) <= pEndSlope))
            {
                if (LocationManager.distanceCheck(LocationManager.getVectorFromPoint(Source), new Vector2(x, y), range))
                {
                    World[x, y].see(1);
                    int useSub = (mainX ? y : x) + sub;
                    if (World[x, y].isSightBlocking()) //current cell blocked
                    {
                        if (useSub >= 0 && useSub < World.GetLength((mainX ? 1 : 0)) && !World[x + (mainX ? 0 : sub), y + (mainX ? sub : 0)].isSightBlocking()) //prior cell within range AND open...
                            //...incremenet the depth, adjust the endslope and recurse
                            ScanOctantCompact(Source, World, pDepth + 1, pOctant, pStartSlope, GetSlope((mainX ? x - .5 * main : x + sub * .5), (!mainX ? y + .5 * main : y + sub * .5), Source.X, Source.Y, mainX), range);
                    }
                    else
                    {
                        if (useSub >= 0 && useSub < World.GetLength((mainX ? 1 : 0)) && World[x + (mainX ? 0 : sub), y + (mainX ? sub : 0)].isSightBlocking()) //prior cell within range AND open...
                            //..adjust the startslope
                            pStartSlope = GetSlope((mainX ? x + .5 * main : x + sub * .5), (!mainX ? y + .5 * main : y + sub * .5), Source.X, Source.Y, mainX);
                    }
                }
                if (mainX)
                {
                    y -= sub;
                }
                else
                {
                    x -= sub;
                }
            }
            if (mainX)
            {
                y += sub;
            }
            else
            {
                x += sub;
            }

            if (x < 0)
                x = 0;
            else if (x >= World.GetLength(0))
                x = World.GetLength(0) - 1;

            if (y < 0)
                y = 0;
            else if (y >= World.GetLength(1))
                y = World.GetLength(1) - 1;

            if (pDepth < range & !World[x, y].isSightBlocking())
                ScanOctantCompact(Source, World, pDepth + 1, pOctant, pStartSlope, pEndSlope, range);
        }

        */

        /// <summary>
        /// Examine the provided octant and calculate the visible cells within it.
        /// </summary>
        /// <param name="pDepth">Depth of the scan</param>
        /// <param name="pOctant">Octant being examined</param>
        /// <param name="pStartSlope">Start slope of the octant</param>
        /// <param name="pEndSlope">End slope of the octance</param>
        protected static void ScanOctant(Point Source, I_Seeable[,] World, int pDepth, int pOctant, double pStartSlope, double pEndSlope, int range)
        {
            int visrange2 = range * range;
            int x = 0;
            int y = 0;

            switch (pOctant)
            {
                case 1: //nnw // 0, -1
                    // -1, 0
                    y = Source.Y - pDepth;
                    if (y < 0) return;

                    x = Source.X - Convert.ToInt32((pStartSlope * Convert.ToDouble(pDepth)));
                    if (x < 0) x = 0;

                    while (GetSlope(x, y, Source.X, Source.Y, false) >= pEndSlope)
                    {
                        if (LocationManager.distanceCheck(LocationManager.getVectorFromPoint(Source), new Vector2(x, y), range))
                        {
                            World[x, y].see(1);
                            if (World[x, y].isSightBlocking()) //current cell blocked
                            {
                                if (x - 1 >= 0 && !World[x - 1, y].isSightBlocking()) //prior cell within range AND open...
                                    //...incremenet the depth, adjust the endslope and recurse
                                    ScanOctant(Source, World, pDepth + 1, pOctant, pStartSlope, GetSlope(x - 0.5, y + 0.5, Source.X, Source.Y, false), range);
                            }
                            else
                            {
                                if (x - 1 >= 0 && World[x - 1, y].isSightBlocking()) //prior cell within range AND open...
                                    //..adjust the startslope
                                    pStartSlope = GetSlope(x - 0.5, y - 0.5, Source.X, Source.Y, false);
                            }
                        }
                        x++;
                    }
                    x--;
                    break;

                case 2: //nne

                    y = Source.Y - pDepth;
                    if (y < 0) return;

                    x = Source.X + Convert.ToInt32((pStartSlope * Convert.ToDouble(pDepth)));
                    if (x >= World.GetLength(0)) x = World.GetLength(0) - 1;

                    while (GetSlope(x, y, Source.X, Source.Y, false) <= pEndSlope)
                    {
                        if (GetVisDistance(x, y, Source.X, Source.Y) <= visrange2)
                        {
                            World[x, y].see(1);
                            if (World[x, y].isSightBlocking())
                            {
                                if (x + 1 < World.GetLength(0) && !World[x + 1, y].isSightBlocking())
                                    ScanOctant(Source, World, pDepth + 1, pOctant, pStartSlope, GetSlope(x + 0.5, y + 0.5, Source.X, Source.Y, false), range);
                            }
                            else
                            {
                                if (x + 1 < World.GetLength(0) && World[x + 1, y].isSightBlocking())
                                    pStartSlope = -GetSlope(x + 0.5, y - 0.5, Source.X, Source.Y, false);
                            }
                        }
                        x--;
                    }
                    x++;
                    break;

                case 3:

                    x = Source.X + pDepth;
                    if (x >= World.GetLength(0)) return;

                    y = Source.Y - Convert.ToInt32((pStartSlope * Convert.ToDouble(pDepth)));
                    if (y < 0) y = 0;

                    while (GetSlope(x, y, Source.X, Source.Y, true) <= pEndSlope)
                    {
                        if (GetVisDistance(x, y, Source.X, Source.Y) <= visrange2)
                        {
                            World[x, y].see(1);
                            if (World[x, y].isSightBlocking())
                            {
                                if (y - 1 >= 0 && !World[x, y - 1].isSightBlocking())
                                    ScanOctant(Source, World, pDepth + 1, pOctant, pStartSlope, GetSlope(x - 0.5, y - 0.5, Source.X, Source.Y, true), range);
                            }
                            else
                            {
                                if (y - 1 >= 0 && World[x, y - 1].isSightBlocking())
                                    pStartSlope = -GetSlope(x + 0.5, y - 0.5, Source.X, Source.Y, true);
                            }
                        }
                        y++;
                    }
                    y--;
                    break;

                case 4:

                    x = Source.X + pDepth;
                    if (x >= World.GetLength(0)) return;

                    y = Source.Y + Convert.ToInt32((pStartSlope * Convert.ToDouble(pDepth)));
                    if (y >= World.GetLength(1)) y = World.GetLength(1) - 1;

                    while (GetSlope(x, y, Source.X, Source.Y, true) >= pEndSlope)
                    {
                        if (GetVisDistance(x, y, Source.X, Source.Y) <= visrange2)
                        {
                            World[x, y].see(1);
                            if (World[x, y].isSightBlocking())
                            {
                                if (y + 1 < World.GetLength(1) && !World[x, y + 1].isSightBlocking())
                                    ScanOctant(Source, World, pDepth + 1, pOctant, pStartSlope, GetSlope(x - 0.5, y + 0.5, Source.X, Source.Y, true), range);
                            }
                            else
                            {
                                if (y + 1 < World.GetLength(1) && World[x, y + 1].isSightBlocking())
                                    pStartSlope = GetSlope(x + 0.5, y + 0.5, Source.X, Source.Y, true);
                            }
                        }
                        y--;
                    }
                    y++;
                    break;

                case 5:

                    y = Source.Y + pDepth;
                    if (y >= World.GetLength(1)) return;

                    x = Source.X + Convert.ToInt32((pStartSlope * Convert.ToDouble(pDepth)));
                    if (x >= World.GetLength(0)) x = World.GetLength(0) - 1;

                    while (GetSlope(x, y, Source.X, Source.Y, false) >= pEndSlope)
                    {
                        if (GetVisDistance(x, y, Source.X, Source.Y) <= visrange2)
                        {
                            World[x, y].see(1);
                            if (World[x, y].isSightBlocking())
                            {
                                if (x + 1 < World.GetLength(1) && !World[x + 1, y].isSightBlocking())
                                    ScanOctant(Source, World, pDepth + 1, pOctant, pStartSlope, GetSlope(x + 0.5, y - 0.5, Source.X, Source.Y, false), range);
                            }
                            else
                            {
                                if (x + 1 < World.GetLength(1)
                                        && World[x + 1, y].isSightBlocking())
                                    pStartSlope = GetSlope(x + 0.5, y + 0.5, Source.X, Source.Y, false);
                            }
                        }
                        x--;
                    }
                    x++;
                    break;

                case 6:

                    y = Source.Y + pDepth;
                    if (y >= World.GetLength(1)) return;

                    x = Source.X - Convert.ToInt32((pStartSlope * Convert.ToDouble(pDepth)));
                    if (x < 0) x = 0;

                    while (GetSlope(x, y, Source.X, Source.Y, false) <= pEndSlope)
                    {
                        if (GetVisDistance(x, y, Source.X, Source.Y) <= visrange2)
                        {
                            World[x, y].see(1);
                            if (World[x, y].isSightBlocking())
                            {
                                if (x - 1 >= 0 && !World[x - 1, y].isSightBlocking())
                                    ScanOctant(Source, World, pDepth + 1, pOctant, pStartSlope, GetSlope(x - 0.5, y - 0.5, Source.X, Source.Y, false), range);
                            }
                            else
                            {
                                if (x - 1 >= 0
                                        && World[x - 1, y].isSightBlocking())
                                    pStartSlope = -GetSlope(x - 0.5, y + 0.5, Source.X, Source.Y, false);
                            }
                        }
                        x++;
                    }
                    x--;
                    break;

                case 7:

                    x = Source.X - pDepth;
                    if (x < 0) return;

                    y = Source.Y + Convert.ToInt32((pStartSlope * Convert.ToDouble(pDepth)));
                    if (y >= World.GetLength(1)) y = World.GetLength(1) - 1;

                    while (GetSlope(x, y, Source.X, Source.Y, true) <= pEndSlope)
                    {
                        if (GetVisDistance(x, y, Source.X, Source.Y) <= visrange2)
                        {
                            World[x, y].see(1);
                            if (World[x, y].isSightBlocking())
                            {
                                if (y + 1 < World.GetLength(1) && !World[x, y + 1].isSightBlocking())
                                    ScanOctant(Source, World, pDepth + 1, pOctant, pStartSlope, GetSlope(x + 0.5, y + 0.5, Source.X, Source.Y, true), range);
                            }
                            else
                            {
                                if (y + 1 < World.GetLength(1) && World[x, y + 1].isSightBlocking())
                                    pStartSlope = -GetSlope(x - 0.5, y + 0.5, Source.X, Source.Y, true);
                            }
                        }
                        y--;
                    }
                    y++;
                    break;

                case 8: //wnw

                    x = Source.X - pDepth;
                    if (x < 0) return;

                    y = Source.Y - Convert.ToInt32((pStartSlope * Convert.ToDouble(pDepth)));
                    if (y < 0) y = 0;

                    while (GetSlope(x, y, Source.X, Source.Y, true) >= pEndSlope)
                    {
                        if (GetVisDistance(x, y, Source.X, Source.Y) <= visrange2)
                        {
                            World[x, y].see(1);
                            if (World[x, y].isSightBlocking())
                            {
                                if (y - 1 >= 0 && !World[x, y - 1].isSightBlocking())
                                    ScanOctant(Source, World, pDepth + 1, pOctant, pStartSlope, GetSlope(x + 0.5, y - 0.5, Source.X, Source.Y, true), range);
                            }
                            else
                            {
                                if (y - 1 >= 0 && World[x, y - 1].isSightBlocking())
                                    pStartSlope = GetSlope(x - 0.5, y - 0.5, Source.X, Source.Y, true);
                            }
                        }
                        y++;
                    }
                    y--;
                    break;
            }

            if (x < 0)
                x = 0;
            else if (x >= World.GetLength(0))
                x = World.GetLength(0) - 1;

            if (y < 0)
                y = 0;
            else if (y >= World.GetLength(1))
                y = World.GetLength(1) - 1;

            if (pDepth < range & !World[x, y].isSightBlocking())
                ScanOctant(Source, World, pDepth + 1, pOctant, pStartSlope, pEndSlope, range);
        }

        protected static bool[,] ScanOctant(Point Source, bool[,] World, bool[,] Ret, int pDepth, int pOctant, double pStartSlope, double pEndSlope, int range)
        {
            int visrange2 = range * range;
            int x = 0;
            int y = 0;

            switch (pOctant)
            {
                case 1: //nnw // 0, -1
                    // -1, 0
                    y = Source.Y - pDepth;
                    if (y < 0) return Ret;

                    x = Source.X - Convert.ToInt32((pStartSlope * Convert.ToDouble(pDepth)));
                    if (x < 0) x = 0;

                    while (GetSlope(x, y, Source.X, Source.Y, false) >= pEndSlope)
                    {
                        if (LocationManager.distanceCheck(LocationManager.getVectorFromPoint(Source), new Vector2(x, y), range))
                        {
                            Ret[x, y] = true;
                            if (World[x, y]) //current cell blocked
                            {
                                if (x - 1 >= 0 && !World[x - 1, y]) //prior cell within range AND open...
                                    //...incremenet the depth, adjust the endslope and recurse
                                    ScanOctant(Source, World, Ret, pDepth + 1, pOctant, pStartSlope, GetSlope(x - 0.5, y + 0.5, Source.X, Source.Y, false), range);
                            }
                            else
                            {
                                if (x - 1 >= 0 && World[x - 1, y]) //prior cell within range AND open...
                                    //..adjust the startslope
                                    pStartSlope = GetSlope(x - 0.5, y - 0.5, Source.X, Source.Y, false);
                            }
                        }
                        x++;
                    }
                    x--;
                    break;

                case 2: //nne

                    y = Source.Y - pDepth;
                    if (y < 0) return Ret;

                    x = Source.X + Convert.ToInt32((pStartSlope * Convert.ToDouble(pDepth)));
                    if (x >= World.GetLength(0)) x = World.GetLength(0) - 1;

                    while (GetSlope(x, y, Source.X, Source.Y, false) <= pEndSlope)
                    {
                        if (GetVisDistance(x, y, Source.X, Source.Y) <= visrange2)
                        {
                            Ret[x, y] = true;
                            if (World[x, y])
                            {
                                if (x + 1 < World.GetLength(0) && !World[x + 1, y])
                                    ScanOctant(Source, World, Ret, pDepth + 1, pOctant, pStartSlope, GetSlope(x + 0.5, y + 0.5, Source.X, Source.Y, false), range);
                            }
                            else
                            {
                                if (x + 1 < World.GetLength(0) && World[x + 1, y])
                                    pStartSlope = -GetSlope(x + 0.5, y - 0.5, Source.X, Source.Y, false);
                            }
                        }
                        x--;
                    }
                    x++;
                    break;

                case 3:

                    x = Source.X + pDepth;
                    if (x >= World.GetLength(0)) return Ret;

                    y = Source.Y - Convert.ToInt32((pStartSlope * Convert.ToDouble(pDepth)));
                    if (y < 0) y = 0;

                    while (GetSlope(x, y, Source.X, Source.Y, true) <= pEndSlope)
                    {
                        if (GetVisDistance(x, y, Source.X, Source.Y) <= visrange2)
                        {
                            Ret[x, y] = true;
                            if (World[x, y])
                            {
                                if (y - 1 >= 0 && !World[x, y - 1])
                                    ScanOctant(Source, World, Ret, pDepth + 1, pOctant, pStartSlope, GetSlope(x - 0.5, y - 0.5, Source.X, Source.Y, true), range);
                            }
                            else
                            {
                                if (y - 1 >= 0 && World[x, y - 1])
                                    pStartSlope = -GetSlope(x + 0.5, y - 0.5, Source.X, Source.Y, true);
                            }
                        }
                        y++;
                    }
                    y--;
                    break;

                case 4:

                    x = Source.X + pDepth;
                    if (x >= World.GetLength(0)) return Ret;

                    y = Source.Y + Convert.ToInt32((pStartSlope * Convert.ToDouble(pDepth)));
                    if (y >= World.GetLength(1)) y = World.GetLength(1) - 1;

                    while (GetSlope(x, y, Source.X, Source.Y, true) >= pEndSlope)
                    {
                        if (GetVisDistance(x, y, Source.X, Source.Y) <= visrange2)
                        {
                            Ret[x, y] = true;
                            if (World[x, y])
                            {
                                if (y + 1 < World.GetLength(1) && !World[x, y + 1])
                                    ScanOctant(Source, World, Ret, pDepth + 1, pOctant, pStartSlope, GetSlope(x - 0.5, y + 0.5, Source.X, Source.Y, true), range);
                            }
                            else
                            {
                                if (y + 1 < World.GetLength(1) && World[x, y + 1])
                                    pStartSlope = GetSlope(x + 0.5, y + 0.5, Source.X, Source.Y, true);
                            }
                        }
                        y--;
                    }
                    y++;
                    break;

                case 5:

                    y = Source.Y + pDepth;
                    if (y >= World.GetLength(1)) return Ret;

                    x = Source.X + Convert.ToInt32((pStartSlope * Convert.ToDouble(pDepth)));
                    if (x >= World.GetLength(0)) x = World.GetLength(0) - 1;

                    while (GetSlope(x, y, Source.X, Source.Y, false) >= pEndSlope)
                    {
                        if (GetVisDistance(x, y, Source.X, Source.Y) <= visrange2)
                        {
                            Ret[x, y] = true;
                            if (World[x, y])
                            {
                                if (x + 1 < World.GetLength(1) && !World[x + 1, y])
                                    ScanOctant(Source, World, Ret, pDepth + 1, pOctant, pStartSlope, GetSlope(x + 0.5, y - 0.5, Source.X, Source.Y, false), range);
                            }
                            else
                            {
                                if (x + 1 < World.GetLength(1)
                                        && World[x + 1, y])
                                    pStartSlope = GetSlope(x + 0.5, y + 0.5, Source.X, Source.Y, false);
                            }
                        }
                        x--;
                    }
                    x++;
                    break;

                case 6:

                    y = Source.Y + pDepth;
                    if (y >= World.GetLength(1)) return Ret;

                    x = Source.X - Convert.ToInt32((pStartSlope * Convert.ToDouble(pDepth)));
                    if (x < 0) x = 0;

                    while (GetSlope(x, y, Source.X, Source.Y, false) <= pEndSlope)
                    {
                        if (GetVisDistance(x, y, Source.X, Source.Y) <= visrange2)
                        {
                            Ret[x, y] = true;
                            if (World[x, y])
                            {
                                if (x - 1 >= 0 && !World[x - 1, y])
                                    ScanOctant(Source, World, Ret, pDepth + 1, pOctant, pStartSlope, GetSlope(x - 0.5, y - 0.5, Source.X, Source.Y, false), range);
                            }
                            else
                            {
                                if (x - 1 >= 0
                                        && World[x - 1, y])
                                    pStartSlope = -GetSlope(x - 0.5, y + 0.5, Source.X, Source.Y, false);
                            }
                        }
                        x++;
                    }
                    x--;
                    break;

                case 7:

                    x = Source.X - pDepth;
                    if (x < 0) return Ret;

                    y = Source.Y + Convert.ToInt32((pStartSlope * Convert.ToDouble(pDepth)));
                    if (y >= World.GetLength(1)) y = World.GetLength(1) - 1;

                    while (GetSlope(x, y, Source.X, Source.Y, true) <= pEndSlope)
                    {
                        if (GetVisDistance(x, y, Source.X, Source.Y) <= visrange2)
                        {
                            Ret[x, y] = true;
                            if (World[x, y])
                            {
                                if (y + 1 < World.GetLength(1) && !World[x, y + 1])
                                    ScanOctant(Source, World, Ret, pDepth + 1, pOctant, pStartSlope, GetSlope(x + 0.5, y + 0.5, Source.X, Source.Y, true), range);
                            }
                            else
                            {
                                if (y + 1 < World.GetLength(1) && World[x, y + 1])
                                    pStartSlope = -GetSlope(x - 0.5, y + 0.5, Source.X, Source.Y, true);
                            }
                        }
                        y--;
                    }
                    y++;
                    break;

                case 8: //wnw

                    x = Source.X - pDepth;
                    if (x < 0) return Ret;

                    y = Source.Y - Convert.ToInt32((pStartSlope * Convert.ToDouble(pDepth)));
                    if (y < 0) y = 0;

                    while (GetSlope(x, y, Source.X, Source.Y, true) >= pEndSlope)
                    {
                        if (GetVisDistance(x, y, Source.X, Source.Y) <= visrange2)
                        {
                            Ret[x, y] = true;
                            if (World[x, y])
                            {
                                if (y - 1 >= 0 && !World[x, y - 1])
                                    ScanOctant(Source, World, Ret, pDepth + 1, pOctant, pStartSlope, GetSlope(x + 0.5, y - 0.5, Source.X, Source.Y, true), range);
                            }
                            else
                            {
                                if (y - 1 >= 0 && World[x, y - 1])
                                    pStartSlope = GetSlope(x - 0.5, y - 0.5, Source.X, Source.Y, true);
                            }
                        }
                        y++;
                    }
                    y--;
                    break;
            }

            if (x < 0)
                x = 0;
            else if (x >= World.GetLength(0))
                x = World.GetLength(0) - 1;

            if (y < 0)
                y = 0;
            else if (y >= World.GetLength(1))
                y = World.GetLength(1) - 1;

            if (pDepth < range & !World[x, y])
                ScanOctant(Source, World, Ret, pDepth + 1, pOctant, pStartSlope, pEndSlope, range);
            return Ret;
        }

        /// <summary>
        /// Get the gradient of the slope formed by the two points
        /// </summary>
        /// <param name="pX1"></param>
        /// <param name="pY1"></param>
        /// <param name="pX2"></param>
        /// <param name="pY2"></param>
        /// <param name="pInvert">Invert slope</param>
        /// <returns></returns>
        private static double GetSlope(double pX1, double pY1, double pX2, double pY2, bool pInvert)
        {
            if (pInvert)
                return (pY1 - pY2) / (pX1 - pX2);
            else
                return (pX1 - pX2) / (pY1 - pY2);
        }

        /// <summary>
        /// Calculate the distance between the two points
        /// </summary>
        /// <param name="pX1"></param>
        /// <param name="pY1"></param>
        /// <param name="pX2"></param>
        /// <param name="pY2"></param>
        /// <returns>Distance</returns>
        private static int GetVisDistance(int pX1, int pY1, int pX2, int pY2)
        {
            return ((pX1 - pX2) * (pX1 - pX2)) + ((pY1 - pY2) * (pY1 - pY2));
        }

        #endregion NewFOV
    }

    public interface I_Seeable
    {
        bool isSightBlocking();

        void see(float percent);

        void debug(string s);
    }
}﻿using System;

namespace NCodeRiddian
{
    public abstract class GlobalRandom
    {
        public static Random random = new Random();

        public static double NextBetween(double d1, double d2)
        {
            return d1 + (random.NextDouble() * (d2 - d1));
        }
    }
}﻿using System;
using System.Collections.Generic;
using System.Linq;

namespace NCodeRiddian
{
    public abstract class Heap<T> : IEnumerable<T>
    {
        private const int InitialCapacity = 0;
        private const int GrowFactor = 2;
        private const int MinGrow = 1;

        private int _capacity = InitialCapacity;
        private T[] _heap = new T[InitialCapacity];
        private int _tail = 0;

        public int Count { get { return _tail; } }

        public int Capacity { get { return _capacity; } }

        protected Comparer<T> Comparer { get; private set; }

        protected abstract bool Dominates(T x, T y);

        protected Heap()
            : this(Comparer<T>.Default)
        {
        }

        protected Heap(Comparer<T> comparer)
            : this(Enumerable.Empty<T>(), comparer)
        {
        }

        protected Heap(IEnumerable<T> collection)
            : this(collection, Comparer<T>.Default)
        {
        }

        protected Heap(IEnumerable<T> collection, Comparer<T> comparer)
        {
            if (collection == null) throw new ArgumentNullException("collection");
            if (comparer == null) throw new ArgumentNullException("comparer");

            Comparer = comparer;

            foreach (var item in collection)
            {
                if (Count == Capacity)
                    Grow();

                _heap[_tail++] = item;
            }

            for (int i = Parent(_tail - 1); i >= 0; i--)
                BubbleDown(i);
        }

        public void Add(T item)
        {
            if (Count == Capacity)
                Grow();

            _heap[_tail++] = item;
            BubbleUp(_tail - 1);
        }

        private void BubbleUp(int i)
        {
            if (i == 0 || Dominates(_heap[Parent(i)], _heap[i]))
                return; //correct domination (or root)

            Swap(i, Parent(i));
            BubbleUp(Parent(i));
        }

        public T GetMin()
        {
            if (Count == 0) throw new InvalidOperationException("Heap is empty");
            return _heap[0];
        }

        public T ExtractDominating()
        {
            if (Count == 0) throw new InvalidOperationException("Heap is empty");
            T ret = _heap[0];
            _tail--;
            Swap(_tail, 0);
            BubbleDown(0);
            return ret;
        }

        private void BubbleDown(int i)
        {
            int dominatingNode = Dominating(i);
            if (dominatingNode == i) return;
            Swap(i, dominatingNode);
            BubbleDown(dominatingNode);
        }

        private int Dominating(int i)
        {
            int dominatingNode = i;
            dominatingNode = GetDominating(YoungChild(i), dominatingNode);
            dominatingNode = GetDominating(OldChild(i), dominatingNode);

            return dominatingNode;
        }

        private int GetDominating(int newNode, int dominatingNode)
        {
            if (newNode < _tail && !Dominates(_heap[dominatingNode], _heap[newNode]))
                return newNode;
            else
                return dominatingNode;
        }

        private void Swap(int i, int j)
        {
            T tmp = _heap[i];
            _heap[i] = _heap[j];
            _heap[j] = tmp;
        }

        private static int Parent(int i)
        {
            return (i + 1) / 2 - 1;
        }

        private static int YoungChild(int i)
        {
            return (i + 1) * 2 - 1;
        }

        private static int OldChild(int i)
        {
            return YoungChild(i) + 1;
        }

        private void Grow()
        {
            int newCapacity = _capacity * GrowFactor + MinGrow;
            var newHeap = new T[newCapacity];
            Array.Copy(_heap, newHeap, _capacity);
            _heap = newHeap;
            _capacity = newCapacity;
        }

        public IEnumerator<T> GetEnumerator()
        {
            return _heap.Take(Count).GetEnumerator();
        }

        System.Collections.IEnumerator System.Collections.IEnumerable.GetEnumerator()
        {
            return GetEnumerator();
        }
    }

    public class MaxHeap<T> : Heap<T>
    {
        public MaxHeap()
            : this(Comparer<T>.Default)
        {
        }

        public MaxHeap(Comparer<T> comparer)
            : base(comparer)
        {
        }

        public MaxHeap(IEnumerable<T> collection, Comparer<T> comparer)
            : base(collection, comparer)
        {
        }

        public MaxHeap(IEnumerable<T> collection)
            : base(collection)
        {
        }

        protected override bool Dominates(T x, T y)
        {
            return Comparer.Compare(x, y) >= 0;
        }
    }

    public class MinHeap<T> : Heap<T>
    {
        public MinHeap()
            : this(Comparer<T>.Default)
        {
        }

        public MinHeap(Comparer<T> comparer)
            : base(comparer)
        {
        }

        public MinHeap(IEnumerable<T> collection)
            : base(collection)
        {
        }

        public MinHeap(IEnumerable<T> collection, Comparer<T> comparer)
            : base(collection, comparer)
        {
        }

        protected override bool Dominates(T x, T y)
        {
            return Comparer.Compare(x, y) <= 0;
        }
    }
}﻿using Microsoft.Xna.Framework;
using Microsoft.Xna.Framework.Graphics;

namespace NCodeRiddian
{
    public class Image
    {
        protected Texture2D image;
        private string TextureManagerDefinition;

        public static explicit operator Texture2D(Image i)
        {
            return i.getTexture();
        }

        public Image(Texture2D imageArt)
        {
            image = imageArt;
        }

        public Image(string TextureManagerName)
        {
            TextureManagerDefinition = TextureManagerName;
            image = TextureManager.getTexture(TextureManagerDefinition);
        }

        public Texture2D getTexture()
        {
            return image;
        }

        public void setImage(Texture2D newImage)
        {
            image = newImage;
        }
    }

    public class AnimatedImage : Image
    {
        protected Point frameS;
        protected Rectangle currentFrame;
        protected int framesleep;
        protected int maxFrameSleep;
        protected int NumberOfFrames;
        public onFinish onFinishAction;
        public onFinishParams parameterFinish;

        public AnimatedImage(Texture2D animationArt, Point frameSize, int frameSleepTime, int frameNum)
            : base(animationArt)
        {
            frameS = frameSize;
            currentFrame = new Rectangle(0, 0, frameSize.X, frameSize.Y);
            maxFrameSleep = frameSleepTime;
            framesleep = maxFrameSleep;

            NumberOfFrames = frameNum;
        }

        public Point getFrameSize()
        {
            return frameS;
        }

        public void reset()
        {
            currentFrame = new Rectangle(0, 0, currentFrame.Width, currentFrame.Height);
            framesleep = maxFrameSleep;
        }

        public int getFrameSleep()
        {
            return maxFrameSleep;
        }

        public int getNumberOfFrames()
        {
            return NumberOfFrames;
        }

        public void setFrameDelay(int i)
        {
            maxFrameSleep = i;
        }

        public virtual void applyStep()
        {
            framesleep--;
            if (framesleep <= 0)
            {
                framesleep = maxFrameSleep;
                currentFrame.X += frameS.X;

                if (currentFrame.X >= base.image.Width || (currentFrame.X / frameS.X) + ((getTexture().Width / frameS.X) * (currentFrame.Y / frameS.Y)) >= NumberOfFrames)
                {
                    if (onFinishAction != null)
                        onFinishAction(this);
                    currentFrame.X = 0;
                    currentFrame.Y += frameS.Y;
                    currentFrame.Y %= getTexture().Height;
                }
            }
        }

        public virtual void applyStep(params object[] onfinishparam)
        {
            framesleep--;
            if (framesleep <= 0)
            {
                framesleep = maxFrameSleep;
                currentFrame.X += frameS.X;

                if (currentFrame.X >= base.image.Width || (currentFrame.X / frameS.X) + ((getTexture().Width / frameS.X) * (currentFrame.Y / frameS.Y)) >= NumberOfFrames)
                {
                    if (parameterFinish != null)
                        parameterFinish(this, onfinishparam);
                    currentFrame.X = 0;
                    currentFrame.Y += frameS.Y;
                    currentFrame.Y %= getTexture().Height;
                }
            }
        }

        public delegate void onFinish(AnimatedImage thisImage);

        public delegate void onFinishParams(AnimatedImage thisImage, params object[] onfinishparam);

        public void skipToStep(int animationStep, bool resetTime)
        {
            currentFrame.X = frameS.X * animationStep;
            currentFrame.X %= getTexture().Width;

            if (resetTime)
                framesleep = maxFrameSleep;
        }

        public Rectangle getFrame()
        {
            return currentFrame;
        }
    }
}﻿using System.Collections.Generic;

namespace NCodeRiddian
{
    public class ImageSet
    {
        private List<List<Image>> imgSet = new List<List<Image>>();

        public void addSet(int setNumber)
        {
            while (imgSet.Count <= setNumber)
                imgSet.Add(new List<Image>());
        }

        public void AddImage(int setNumber, Image i)
        {
            while (imgSet.Count <= setNumber)
                imgSet.Add(new List<Image>());
            imgSet[setNumber].Add(i);
        }

        public Image getRandomImage(int setNumber)
        {
            if (imgSet[setNumber].Count == 0)
                return null;
            return imgSet[setNumber][GlobalRandom.random.Next(imgSet[setNumber].Count)];
        }

        public Image getImage(int setNumber, int imgNumber)
        {
            return imgSet[setNumber][imgNumber];
        }

        public Image this[int i]
        {
            get
            {
                return getRandomImage(i);
            }
            set
            {
                AddImage(i, value);
            }
        }
    }
}﻿using System;
using System.Collections.Generic;
using Microsoft.Xna.Framework;
using Microsoft.Xna.Framework.Graphics;

namespace NCodeRiddian
{
    internal class IDrawableSorter : IComparer<IDRAWABLE>
    {
        public int Compare(IDRAWABLE o1, IDRAWABLE o2)
        {
            return ((IDRAWABLE)o1).getDrawLocation().Y - ((IDRAWABLE)o2).getDrawLocation().Y;
        }
    }

    public class IsoCamera
    {
        private static Point origCamSize;
        private static Point camSize;
        public static float camAttack;
        private static float topEdge;
        public static Point cameraPosition;
        public static float zoom;
        public static int Skew;

        private static List<IDRAWABLE> ThingsToDraw = new List<IDRAWABLE>();

        public static void setupCamera(Point cameraSize, float cameraAngle)
        {
            camSize = cameraSize;
            origCamSize = camSize;
            camAttack = cameraAngle;
            topEdge = camSize.X / camAttack;
            zoom = 1;
        }

        public static void addToRenderQueue(IDRAWABLE item)
        {
            ThingsToDraw.Add(item);
        }

        public static void removeFromRenderQueue(IDRAWABLE toRemove)
        {
            ThingsToDraw.Remove(toRemove);
        }

        public static void clearRenderQueue()
        {
            ThingsToDraw.Clear();
        }

        private static int shiftDrawLocation(int x, float y)
        {//camSize.X * .75f
            int dif = (int)(x - ((cameraPosition.X + Skew) + (topEdge / 2f)));
            //Console.Out.WriteLine("Adj:" + ((dif * y) / camAttack));
            return (int)Math.Round(x + (((dif * y) / camAttack)) * (1 - camAttack));
        }

        public static void Draw(SpriteBatch sb)
        {
            sb.Begin(SpriteSortMode.BackToFront, null);

            foreach (IDRAWABLE i in ThingsToDraw)
            {
                if (i.getDrawLocation().Y - (i.getDrawLocation().Height / 2) < cameraPosition.Y + camSize.Y)
                {
                    sb.Draw(i.getTexture(), new Rectangle(shiftDrawLocation(i.getDrawLocation().X, getHeightMod(i.getDrawLocation().Y)) - cameraPosition.X,
                                                          i.getDrawLocation().Y - cameraPosition.Y,
                                                          (int)Math.Ceiling((float)i.getDrawLocation().Width * getTotalZoom(i.getDrawLocation().Y)),
                                                          (int)Math.Ceiling((float)i.getDrawLocation().Height * getTotalZoom(i.getDrawLocation().Y))
                                                          ), null, i.getTintColor(), i.getRotation(), i.getDrawOrigin(), i.getFlipEffect(),
                                                          1 - getHeightMod(i.getDrawLocation().Y));
                }
            }

            sb.End();
        }

        public static Rectangle getFullScreen()
        {
            return new Rectangle(cameraPosition.X, cameraPosition.Y, (int)Math.Round(topEdge), camSize.Y);
        }

        public static void DrawIndiv(SpriteBatch sb, Image image, Rectangle r, Color c, Rectangle? sourceRectangle, float rotation, Vector2 origin, SpriteEffects effects)
        {
            r.X -= (int)Math.Round(origin.X);
            r.Y -= (int)Math.Round(origin.Y);
            r.X = shiftDrawLocation(r.X, getHeightMod(r.Y + origin.Y));
            if (getFullScreen().Intersects(r))
            {
                r.X += (int)Math.Round(origin.X);
                r.Y += (int)Math.Round(origin.Y);
                sb.Draw(image.getTexture(),
                        new Rectangle(
                            (int)shiftDrawLocation(r.X, getHeightMod(r.Y)) - cameraPosition.X,
                            (int)r.Y - cameraPosition.Y,
                            (int)Math.Ceiling(r.Width * getTotalZoom(r.Y)),
                            (int)Math.Ceiling(r.Height * getTotalZoom(r.Y))),
                            sourceRectangle == null && image is AnimatedImage ? ((AnimatedImage)image).getFrame() : sourceRectangle,
                            c, rotation, origin, effects, 1 - getHeightMod(r.Y));
            }
        }

        private static float getHeightMod(float y)
        {
            return (y - (float)cameraPosition.Y) / (float)camSize.Y;
        }

        private static float getRawZoom(float y)
        {
            return (getHeightMod(y) / camAttack);
        }

        private static float getTotalZoom(float y)
        {
            return (getRawZoom(y) + camAttack) - (getRawZoom(y) * camAttack);
        }
    }

    public interface IDRAWABLE
    {
        Texture2D getTexture();

        Rectangle getDrawLocation();

        Vector2 getDrawOrigin();

        float getRotation();

        Color getTintColor();

        SpriteEffects getFlipEffect();
    }
}﻿using Microsoft.Xna.Framework.Input;

namespace NCodeRiddian
{
    public abstract class KeyboardInputManager
    {
        private static KeyboardState oldState = Keyboard.GetState();
        private static KeyboardState newState = Keyboard.GetState();

        /// <summary>
        /// To be called at the start of every update the KeyboardManager will be used.
        /// </summary>
        public static void update()
        {
            oldState = newState;
            newState = Keyboard.GetState();
        }

        /// <summary>
        /// Returns if a key is currently pressed
        /// </summary>
        /// <param name="k"></param>
        /// <returns></returns>
        public static bool isKeyDown(Keys k)
        {
            return newState.IsKeyDown(k);
        }

        /// <summary>
        /// Returns if a key was pressed this update
        /// </summary>
        /// <param name="k"></param>
        /// <returns></returns>
        public static bool isKeyPressed(Keys k)
        {
            return newState.IsKeyDown(k) && oldState.IsKeyUp(k);
        }

        /// <summary>
        /// Returns if a key was released this update
        /// </summary>
        /// <param name="k"></param>
        /// <returns></returns>
        public static bool isKeyReleased(Keys k)
        {
            return newState.IsKeyUp(k) && oldState.IsKeyDown(k);
        }
    }
}﻿using System;
using Microsoft.Xna.Framework;

namespace NCodeRiddian
{
    public abstract class LocationManager
    {
        /// <summary>
        /// Gets the rotation in radians between two points
        /// </summary>
        /// <param name="source">The source point</param>
        /// <param name="target">The target point</param>
        /// <returns>Radian value, the rotation between these points.</returns>
        public static float getRotation(Vector2 source, Vector2 target)
        {
            return (float)Math.Atan2(target.Y - source.Y, target.X - source.X);
        }

        public static float getDistance(Vector2 source, Vector2 target)
        {
            return (float)Math.Sqrt(Math.Pow(source.X - target.X, 2) + Math.Pow(source.Y - target.Y, 2));
        }

        public static float getDistanceSquared(Vector2 src, Vector2 tgt)
        {
            return (float)(Math.Pow(src.X - tgt.X, 2) + Math.Pow(src.Y - tgt.Y, 2));
        }

        /// <summary>
        /// Returns the new location of a Vector2 moving based on a rotation and a speed.
        /// </summary>
        /// <param name="source">The start position</param>
        /// <param name="speed">The distance to move</param>
        /// <param name="rotation">The direction to move</param>
        /// <returns>The Point of the new location</returns>
        public static Vector2 moveByRotation(Vector2 source, float speed, float rotation)
        {
            return Vector2.Add(source, new Vector2((float)(speed * Math.Cos(rotation)), (float)(speed * Math.Sin(rotation))));
        }

        public static bool distanceCheck(Vector2 point1, Vector2 point2, float maximum)
        {
            float a = point1.X - point2.X;
            float b = point1.Y - point2.Y;

            return (a * a) + (b * b) <= (maximum * maximum);
        }

        public static Vector2 getVectorFromPoint(Point p)
        {
            return new Vector2(p.X, p.Y);
        }

        public static bool linesIntersect(Vector2 A, Vector2 B, Vector2 C, Vector2 D)
        {
            return MiniIntersect(A, B, C, D) && MiniIntersect(C, D, A, B);
        }

        private static bool MiniIntersect(Vector2 A, Vector2 B, Vector2 C, Vector2 D)
        {
            float var1 = (B.X - A.X) * (C.Y - B.Y) - (B.Y - A.Y) * (C.X - B.X);
            float var2 = (B.X - A.X) * (D.Y - B.Y) - (B.Y - A.Y) * (D.X - B.X);

            return (var1 < 0 && var2 > 0) || (var1 > 0 && var2 < 0);
        }

        public static bool linesIntersect(Vector2[] line1, Vector2[] line2)
        {
            return linesIntersect(line1[0], line1[1], line2[0], line2[1]);
        }

        public static Vector2[][] RectangleEdges(Rectangle r) // T, R, B, L
        {
            Vector2[][] edge = new Vector2[4][];
            edge[0] = new Vector2[2];
            edge[1] = new Vector2[2];
            edge[2] = new Vector2[2];
            edge[3] = new Vector2[2];
            edge[0][0] = getVectorFromPoint(new Point(r.X, r.Y));
            edge[0][1] = getVectorFromPoint(new Point(r.X + r.Width, r.Y));

            edge[1][0] = getVectorFromPoint(new Point(r.X + r.Width, r.Y));
            edge[1][1] = getVectorFromPoint(new Point(r.X + r.Width, r.Y + r.Height));

            edge[2][0] = getVectorFromPoint(new Point(r.X + r.Width, r.Y + r.Height));
            edge[2][1] = getVectorFromPoint(new Point(r.X, r.Y + r.Height));

            edge[3][0] = getVectorFromPoint(new Point(r.X, r.Y + r.Height));
            edge[3][1] = getVectorFromPoint(new Point(r.X, r.Y));

            return edge;
        }

        public static Vector2[] RectangeCorners(Rectangle r) // TL TR BR BL
        {
            return new Vector2[] { new Vector2(r.X, r.Y), new Vector2(r.X + r.Width, r.Y), new Vector2(r.X + r.Width, r.Y + r.Height), new Vector2(r.X, r.Y + r.Width) };
        }

        public static bool FOVCheck(Vector2 pos1, float facing, float FOV, float distance, Vector2 pos2)
        {
            if (!distanceCheck(pos1, pos2, distance))
                return false;
            float dif = getRotation(pos1, pos2) - facing;
            return Math.Abs(dif) < FOV;
        }

        public static Point getPointFromVector(Vector2 v)
        {
            return new Point((int)Math.Round(v.X), (int)Math.Round(v.Y));
        }

        public static Vector2? getIntersectionPoint(Vector2[] src, Vector2[] tgt)
        {
            if (!linesIntersect(src, tgt))
            {
                return null;
            }
            Vector2 si1 = convertLineToSI(src);
            Vector2 si2 = convertLineToSI(tgt);
            Vector2 pointOfIntersection = new Vector2();

            if (!float.IsInfinity(si1.X) && !float.IsInfinity(si2.X))
            {
                pointOfIntersection.X = (si2.Y - si1.Y) / (si1.X - si2.X);
                pointOfIntersection.Y = (si1.X * pointOfIntersection.X) + si1.Y;
            }
            else if (!float.IsInfinity(si2.X))
            {
                pointOfIntersection.X = src[0].X;
                pointOfIntersection.Y = (si2.X * pointOfIntersection.X) + si2.Y;
            }
            else if (!float.IsInfinity(si1.X))
            {
                pointOfIntersection.X = tgt[0].X;
                pointOfIntersection.Y = (si1.X * pointOfIntersection.X) + si1.Y;
            }
            return pointOfIntersection;
        }

        public static Vector2[] getReflectionLine(Vector2[] src, Vector2[] tgt)
        {
            if (!linesIntersect(src, tgt))
            {
                return null;
            }
            Vector2 si1 = convertLineToSI(src);
            Vector2 si2 = convertLineToSI(tgt);

            Vector2 pointOfIntersection = new Vector2();

            if (!float.IsInfinity(si1.X) && !float.IsInfinity(si2.X))
            {
                pointOfIntersection.X = (si2.Y - si1.Y) / (si1.X - si2.X);
                pointOfIntersection.Y = (si1.X * pointOfIntersection.X) + si1.Y;
            }
            else if (!float.IsInfinity(si2.X))
            {
                pointOfIntersection.X = src[0].X;
                pointOfIntersection.Y = (si2.X * pointOfIntersection.X) + si2.Y;
            }
            else if (!float.IsInfinity(si1.X))
            {
                pointOfIntersection.X = tgt[0].X;
                pointOfIntersection.Y = (si1.X * pointOfIntersection.X) + si1.Y;
            }

            float Angle1 = (float)Math.Atan2(src[1].Y - src[0].Y, src[1].X - src[0].X);
            float Angle2 = (float)Math.Atan2(tgt[1].Y - tgt[0].Y, tgt[1].X - tgt[0].X);

            float newAngle = Angle2 + (Angle2 - Angle1);

            float distanceRemaining = LocationManager.getDistance(src[0], src[1]) - LocationManager.getDistance(src[0], pointOfIntersection);

            Vector2[] returnLine = new Vector2[] { pointOfIntersection, moveByRotation(pointOfIntersection, distanceRemaining, newAngle) };

            return returnLine;
        }

        public static Vector2 convertLineToSI(Vector2[] line)
        {
            float slope = (line[1].Y - line[0].Y) / (line[1].X - line[0].X);
            float intersect = line[0].Y + (-line[0].X * slope);

            return new Vector2(slope, intersect);
        }
    }
}﻿using System;
using System.Collections.Generic;
using Microsoft.Xna.Framework;

namespace NCodeRiddian
{
    public abstract class Mapper
    {
        public enum RoundingMode
        {
            Down,
            Up,
            Nearest
        }

        public static void seeTiles(Seeable[,] world, Vector2 location, float angle, float FOV, float distance, RoundingMode rmode, params object[] parameters)
        {
            int topquad = (int)((angle + FOV) / MathHelper.PiOver4);
            int botquad = (int)((angle - FOV) / MathHelper.PiOver4);

            if (topquad == botquad)
            {
                seeTilesQuad(world, location, new Vector2(angle + FOV, angle - FOV), distance, topquad, rmode, parameters);
            }
            else
            {
                seeTilesQuad(world, location, new Vector2(angle + FOV, MathHelper.PiOver4 * Math.Max(topquad, botquad)), distance, topquad, rmode, parameters);
                seeTilesQuad(world, location, new Vector2(MathHelper.PiOver4 * Math.Max(topquad, botquad), angle - FOV), distance, botquad, rmode, parameters);
            }
        }

        private static void seeTilesQuad(Seeable[,] world, Vector2 location, Vector2 angles, float distance, int quad, RoundingMode rmode, params object[] parameters)
        {
            Queue<SightCol> queue = new Queue<SightCol>();
            int tilesize = world[0, 0].getBounds().Width;

            int curDist = 0;

            enqueNext(world, location, tilesize, queue, curDist, angles, quad, rmode);

            while (queue.Count != 0) //Process Row
            {
                curDist++;
                SightCol s = queue.Dequeue();

                Vector2 newAngles = new Vector2(0, 0);
                bool curblock = false;
                bool topused = false;

                bool firstblock = true;

                while (!s.isDone())
                {
                    Seeable seb = s.getNextSeeable();
                    if (LocationManager.distanceCheck(location, new Vector2(seb.getBounds().X, seb.getBounds().Y), distance))
                    {
                        seb.see(parameters);
                        if (firstblock)
                        {
                            firstblock = false;
                            topused = true;
                            newAngles.X = angles.X;
                        }

                        if (seb.isTransparent() && curblock)
                        {
                            topused = true;
                            curblock = false;
                            newAngles.X = getAngleToNessecaryCorner(location, seb.getBounds(), quad, true);
                        }
                        else if (!seb.isTransparent())
                        {
                            if (topused && !curblock)
                            {
                                newAngles.Y = getAngleToNessecaryCorner(location, seb.getBounds(), quad, false);
                                enqueNext(world, location, tilesize, queue, s.cDist + 1, newAngles, quad, rmode);
                            }
                            else if (!curblock)
                            {
                                curblock = true;
                            }
                        }
                    }
                }
                if (curblock)
                {
                    newAngles.Y = s.angles.Y;
                    enqueNext(world, location, tilesize, queue, s.cDist + 1, newAngles, quad, rmode);
                }
            }
        }

        private static float getAngleToNessecaryCorner(Vector2 location, Rectangle r, int quad, bool istop)
        {
            switch (quad)
            {
                case 0:
                    return LocationManager.getRotation(location, istop ? new Vector2(r.X, r.Y + r.Height) : new Vector2(r.X, r.Y));
                case 1:
                    return LocationManager.getRotation(location, istop ? new Vector2(r.X, r.Y + r.Height) : new Vector2(r.X + r.Width, r.Y + r.Height));
                case 2:
                    return LocationManager.getRotation(location, istop ? new Vector2(r.X + r.Width, r.Y + r.Height) : new Vector2(r.X, r.Y + r.Height));
                case 3:
                    return LocationManager.getRotation(location, istop ? new Vector2(r.X + r.Width, r.Y + r.Height) : new Vector2(r.X, r.Y + r.Height));
                case 4:
                    return LocationManager.getRotation(location, istop ? new Vector2(r.X + r.Width, r.Y) : new Vector2(r.X + r.Width, r.Y + r.Height));
                case 5:
                    return LocationManager.getRotation(location, istop ? new Vector2(r.X, r.Y + r.Height) : new Vector2(r.X + r.Width, r.Y));
                case 6:
                    return LocationManager.getRotation(location, istop ? new Vector2(r.X + r.Width, r.Y + r.Height) : new Vector2(r.X, r.Y));
                case 7:
                    return LocationManager.getRotation(location, istop ? new Vector2(r.X, r.Y) : new Vector2(r.X, r.Y + r.Height));
                default:
                    return float.NaN;
            }
        }

        private static void enqueNext(Seeable[,] world, Vector2 location, int tilesize, Queue<SightCol> scols, int curDist, Vector2 angles, int quad, RoundingMode rmode)
        {
            Point sdirs = new Point(getangle(angles.X, quad, curDist, rmode, tilesize), getangle(angles.Y, quad, curDist, rmode, tilesize));
            Point p1dir = new Point((quad == 0 || quad == 7 || quad == 3 || quad == 4) ? (int)((location.X / tilesize) + curDist) : sdirs.X, !(quad == 0 || quad == 7 || quad == 3 || quad == 4) ? (int)((location.Y / tilesize) + curDist) : sdirs.X);
            Point p2dir = new Point((quad == 0 || quad == 7 || quad == 3 || quad == 4) ? (int)((location.X / tilesize) + curDist) : sdirs.Y, !(quad == 0 || quad == 7 || quad == 3 || quad == 4) ? (int)((location.Y / tilesize) + curDist) : sdirs.Y);
            scols.Enqueue(new SightCol(world, p1dir, p2dir, curDist, angles));
        }

        private static int getangle(float angle, int quad, int dist, RoundingMode rmode, int tsize)
        {
            int tgtPoint = tsize * dist;
            double unrounded = 0;
            if (quad == 0 || quad == 7 || quad == 3 || quad == 4)
            {
                unrounded = (double)tgtPoint * Math.Tan(angle);
            }
            else
            {
                unrounded = (double)tgtPoint / Math.Tan(angle);
            }

            switch (rmode)
            {
                case RoundingMode.Up:
                    return (int)Math.Ceiling(unrounded / (double)tsize);
                case RoundingMode.Down:
                    return (int)Math.Floor(unrounded / (double)tsize);
                case RoundingMode.Nearest:
                default:
                    return (int)Math.Round(unrounded / (double)tsize);
            }
        }
    }

    internal struct SightCol
    {
        private Seeable[] seeables;
        public Vector2 angles;
        public int cDist;
        private int cidx;

        public SightCol(Seeable[,] world, Point idx1, Point idx2, int cdist, Vector2 angles)
        {
            seeables = new Seeable[Math.Abs((idx1.X - idx2.X) + (idx1.Y - idx2.Y))];
            for (int x = 0; x < seeables.Length; x++)
            {
                seeables[x] = world[idx1.X, idx1.Y];
                if (idx1.X < idx2.X)
                    idx1.X++;
                else if (idx1.X > idx2.X)
                    idx1.X--;
                else if (idx1.Y > idx2.Y)
                    idx1.Y--;
                else
                    idx1.Y++;
            }
            this.cDist = cdist;
            this.cidx = 0;

            this.angles = angles;
        }

        public Seeable getNextSeeable()
        {
            cidx++;
            return seeables[cidx - 1];
        }

        public Seeable peekNextSeeable()
        {
            return seeables[cidx];
        }

        public bool isDone()
        {
            return cidx >= seeables.Length;
        }
    }

    public interface Seeable
    {
        /// <summary>
        /// Checks if this tile blocks LOS
        /// </summary>
        /// <returns>TRUE if the object is transparent, FALSE otherwise</returns>
        bool isTransparent();

        /// <summary>
        /// Get the "true bounds" (actual position) of the object
        /// </summary>
        /// <returns>Rectangle containing the objects true bounds</returns>
        Rectangle getBounds();

        /// <summary>
        /// Function called when the seeable is seen
        /// </summary>
        /// <param name="param">A list of objects which can be sent to the function</param>
        void see(params object[] parameters);
    }
}﻿using Microsoft.Xna.Framework;

namespace NCodeRiddian
{
    public abstract class MemSave
    {
        private static Rectangle save = new Rectangle(0, 0, 0, 0);
        private static Vector2 savev = new Vector2(0, 0);

        public static Vector2 getv(float x, float y)
        {
            savev.X = x;
            savev.Y = y;
            return savev;
        }

        public static Rectangle getr(int x, int y, int wid, int hei)
        {
            save.X = x;
            save.Y = y;
            save.Width = wid;
            save.Height = hei;
            return save;
        }
    }
}﻿using System.Collections.Generic;
using Microsoft.Xna.Framework;
using Microsoft.Xna.Framework.Graphics;

namespace NCodeRiddian
{
    public class MenuScreen
    {
        private List<I_MenuComponent> MenuComponents;

        public MenuScreen()
        {
            MenuComponents = new List<I_MenuComponent>();
        }

        public void addComponent(I_MenuComponent menuComp)
        {
            MenuComponents.Add(menuComp);
        }
    }

    public interface I_MenuComponent
    {
        void update();

        void draw(SpriteBatch sb);
    }

    public class MC_TextBox : I_MenuComponent
    {
        public void update()
        {
        }

        public void draw(SpriteBatch sb)
        {
        }
    }

    public class MC_Button : I_MenuComponent
    {
        public Image mainImage;
        private Rectangle r;
        private Color tint;
        private OnClickFunction buttonFunction;

        public delegate void OnClickFunction(MC_ButtonClickEvent buttonEvent);

        public MC_Button(Image i, Rectangle location, Color color, OnClickFunction action)
        {
            mainImage = i;
            r = location;
            tint = color;
            buttonFunction = action;
        }

        public void update()
        {
            if (Cursor.leftPress)
            {
                if (r.Intersects(new Rectangle(Cursor.worldLoc().X, Cursor.worldLoc().Y, 1, 1)))
                {
                    buttonFunction(new MC_ButtonClickEvent(this));
                }
            }
        }

        public void draw(SpriteBatch sb)
        {
            Camera.draw(sb, mainImage, r, tint);
        }
    }

    public class MC_ButtonClickEvent
    {
        public MC_Button button;

        public MC_ButtonClickEvent(MC_Button inb)
        {
            button = inb;
        }
    }

    public class MC_Image : I_MenuComponent
    {
        public Image mainImage;
        private Rectangle r;
        private Color tint;

        public MC_Image(Image i, Rectangle location, Color color)
        {
            mainImage = i;
            r = location;
            tint = color;
        }

        public void update()
        {
        }

        public void draw(SpriteBatch sb)
        {
            Camera.draw(sb, mainImage, r, tint);
        }
    }
}﻿using System;
using Microsoft.Xna.Framework;
using Microsoft.Xna.Framework.Graphics;

namespace NCodeRiddian
{
    public class MultiCamera
    {
        public Point CameraLocation;
        private Point CameraStore;
        private float myZoom;

        private float storeZoom;
        private Rectangle ScreenLocation;
        private RenderTarget2D personalTarget;
        private static bool isRunningRender;

        private static RenderTarget2D TOTAL;

        public float zoom
        {
            get
            {
                return myZoom;
            }
            set
            {
                if (value > 0)
                    myZoom = value;
            }
        }

        public static void SETUP(Point screenSize, GraphicsDevice gd)
        {
            TOTAL = new RenderTarget2D(gd, screenSize.X, screenSize.Y, true, gd.PresentationParameters.BackBufferFormat, DepthFormat.Depth16, 0, RenderTargetUsage.PreserveContents);
        }

        public MultiCamera(Rectangle screenLocation, GraphicsDevice gd)
        {
            ScreenLocation = screenLocation;

            personalTarget = new RenderTarget2D(gd, ScreenLocation.Width, ScreenLocation.Height);
            isRunningRender = false;
            CameraLocation = new Point(0, 0);
            myZoom = 1;
        }

        public void assure(Rectangle r)
        {
            Rectangle myrec = getView();
            CameraLocation.X = Math.Max(CameraLocation.X, r.X);
            CameraLocation.Y = Math.Max(CameraLocation.Y, r.Y);
            if (CameraLocation.X + myrec.Width > r.X + r.Width)
            {
                CameraLocation.X = r.X + r.Width - myrec.Width;
            }
            if (CameraLocation.Y + myrec.Height > r.Y + r.Height)
            {
                CameraLocation.Y = r.Y + r.Height - myrec.Height;
            }
        }

        public void advancedAssure(Rectangle r)
        {
            Rectangle myrec = getView();
            if (myrec.Width > r.Width)
            {
                myZoom = ((float)myrec.Width) / ((float)r.Width);
                myrec = getView();
            }
            if (myrec.Height > r.Height)
            {
                myZoom = ((float)myrec.Height) / ((float)r.Height);
            }
            assure(r);
        }

        public void Center(Point p)
        {
            CameraLocation.X = (int)(p.X - (ScreenLocation.Width / zoom / 2));
            CameraLocation.Y = (int)(p.Y - (ScreenLocation.Height / zoom / 2));
        }

        public void Center(Vector2 p)
        {
            Center(LocationManager.getPointFromVector(p));
        }

        public Rectangle getView()
        {
            return MemSave.getr(CameraLocation.X, CameraLocation.Y, (int)Math.Round(ScreenLocation.Width / myZoom), (int)Math.Round(ScreenLocation.Height / myZoom));
        }

        public void startRender(SpriteBatch sb)
        {
            startRender(sb, Color.CornflowerBlue);
        }

        public void startRender(SpriteBatch sb, Color clearColor)
        {
            if (isRunningRender)
                throw new Exception("startRender called while render still running!");

            CameraStore = Camera.getlocation().Location;
            storeZoom = Camera.getZoom();
            Camera.ZoomTo(myZoom);
            Camera.setLocation(CameraLocation);
            sb.GraphicsDevice.SetRenderTarget(personalTarget);
            sb.GraphicsDevice.Clear(clearColor);
            isRunningRender = true;
            sb.Begin();
        }

        public void endRender(SpriteBatch sb)
        {
            if (!isRunningRender)
                throw new Exception("endRender called without starting render!");
            sb.End();

            Camera.setLocation(CameraStore);
            Camera.ZoomTo(storeZoom);
            sb.GraphicsDevice.SetRenderTarget(TOTAL);
            sb.Begin();
            sb.Draw(personalTarget, ScreenLocation, Color.White);
            sb.End();

            isRunningRender = false;
        }

        public static void FINISH(SpriteBatch sb)
        {
            sb.GraphicsDevice.SetRenderTarget(null);
        }

        public static void RENDER(SpriteBatch sb)
        {
            sb.Draw(TOTAL, MemSave.getr(0, 0, TOTAL.Width, TOTAL.Height), Color.White);
        }
    }
}﻿using System;

namespace NCodeRiddian
{
    public class NArray<E>
    {
        private E[] behindArray;
        private int[] dimensions;

        public NArray(int dimension)
        {
            behindArray = new E[dimension];
            dimensions = new int[] { dimension };
        }

        public NArray(params int[] dimension)
        {
            int totalLength = 1;
            foreach (int i in dimension)
                totalLength *= i;
            behindArray = new E[totalLength];
            dimensions = dimension;
        }

        private int getIdx(int[] pos)
        {
            int idx = 0;
            for (int x = 0; x < pos.Length; x++)
            {
                idx += pos[x] * (x - 1 == -1 ? 1 : dimensions[x - 1]);
            }
            return idx;
        }

        public E this[params int[] i]
        {
            get
            {
                try
                {
                    return behindArray[getIdx(i)];
                }
                catch (IndexOutOfRangeException ex)
                {
                    throw new IndexOutOfRangeException("No index " + i, ex);
                }
            }
            set
            {
                try
                {
                    behindArray[getIdx(i)] = value;
                }
                catch (IndexOutOfRangeException ex)
                {
                    throw new IndexOutOfRangeException("No index " + i, ex);
                }
            }
        }

        public int Length()
        {
            return dimensions[0];
        }

        public int Length(int dimension)
        {
            return dimensions[dimension];
        }

        private void eachhelper(int[] position, ADJ adjustmentFunction)
        {
            adjustmentFunction(behindArray[getIdx(position)], position);
            position[0]++;
            bool done = false;
            for (int x = 0; !done && x < position.Length; x++)
            {
                if (position[x] == dimensions[x])
                {
                    position[x] = 0;
                    if (x + 1 >= dimensions.Length)
                        return;
                    position[x + 1]++;
                    eachhelper(position, adjustmentFunction);
                }
            }
        }

        public void each(ADJ adjustmentFunction)
        {
            int[] pos = new int[dimensions.Length];
            for (int x = 0; x < pos.Length; x++)
                pos[x] = 0;
            eachhelper(pos, adjustmentFunction);
        }

        public void each(ADJ2 adjustmentFunction)
        {
            for (int x = 0; x < behindArray.Length; x++)
            {
                adjustmentFunction(behindArray[x]);
            }
        }

        public delegate void ADJ(E element, int[] index);

        public delegate void ADJ2(E element);
    }
}﻿using System;
using System.Collections.Generic;

namespace NCodeRiddian
{
    public class Network<E>
    {
        public const byte C_INPUT = 0;
        public const byte C_HIDDEN = 1;
        public const byte C_OUTPUT = 2;
        public const byte C_ALL = 3;

        public List<InputNeuron<E>> InNeurons;
        public List<HiddenNeuron<E>> HiddenNeurons;
        public List<OutputNeuron<E>> OutNeurons;
        private int totalConnections;

        public static bool forceKill = false;

        public Network()
        {
            InNeurons = new List<InputNeuron<E>>();
            HiddenNeurons = new List<HiddenNeuron<E>>();
            OutNeurons = new List<OutputNeuron<E>>();
        }

        public InputNeuron<E> AddInputNeuron()
        {
            InputNeuron<E> tmp = new InputNeuron<E>();
            InNeurons.Add(tmp);
            return tmp;
        }

        public HiddenNeuron<E> AddHiddenNeuron(HiddenNeuron<E>.NeuronOperation op)
        {
            HiddenNeuron<E> tmp = new HiddenNeuron<E>(op);
            HiddenNeurons.Add(tmp);
            return tmp;
        }

        public OutputNeuron<E> AddOutputNeuron(OutputNeuron<E>.DoOperation op)
        {
            OutputNeuron<E> tmp = new OutputNeuron<E>(op);
            OutNeurons.Add(tmp);
            return tmp;
        }

        public void DisconnectH(int i, int i2)
        {
            HiddenNeurons[i].Disconnect(HiddenNeurons[i2]);
            totalConnections--;
        }

        public void DisconnectIH(int i, int i2)
        {
            InNeurons[i].Disconnect(HiddenNeurons[i2]);
            totalConnections--;
        }

        public void DisconnectHO(int i, int i2)
        {
            HiddenNeurons[i].Disconnect(OutNeurons[i2]);
            totalConnections--;
        }

        public bool ConnectIH(int i, int i2)
        {
            bool v = InNeurons[i].ConnectOutput(HiddenNeurons[i2]);
            if (v)
                totalConnections++;
            return v;
        }

        public bool ConnectH(int i, int i2)
        {
            bool v = HiddenNeurons[i].ConnectOutput(HiddenNeurons[i2]);
            if (v)
                totalConnections++;
            return v;
        }

        public bool ConnectHO(int i, int i2)
        {
            bool v = HiddenNeurons[i].ConnectOutput(OutNeurons[i2]);
            if (v)
                totalConnections++;
            return v;
        }

        public bool ConnectIO(int i, int i2)
        {
            bool v = InNeurons[i].ConnectOutput(OutNeurons[i2]);
            if (v)
                totalConnections++;
            return v;
        }

        public void Fire(int i, params E[] fireparam)
        {
            InNeurons[i].fireNeuron(fireparam);
        }

        public void FireWithLimit(int i, int lim, params E[] fireparam)
        {
            InNeurons[i].fireNeuronLimit(lim, fireparam);
        }

        public void Remove(int i)
        {
            for (int n = HiddenNeurons[i].getInputs().Count - 1; n >= 0; n--)
            {
                HiddenNeurons[i].getInputs()[n].RemoveOutput(HiddenNeurons[i]);
            }
            for (int n = HiddenNeurons[i].getOutputs().Count - 1; n >= 0; n--)
            {
                HiddenNeurons[i].getOutputs()[n].RemoveInput(HiddenNeurons[i]);
            }
            HiddenNeurons.RemoveAt(i);
        }

        public void RemoveAndCross(int i)
        {
            for (int n = HiddenNeurons[i].getInputs().Count - 1; n >= 0; n--)
            {
                foreach (Neuron con in HiddenNeurons[i].getOutputs())
                {
                    HiddenNeurons[i].getInputs()[n].ConnectOutput(con);
                }
                HiddenNeurons[i].getInputs()[n].RemoveOutput(HiddenNeurons[i]);
            }
            for (int n = HiddenNeurons[i].getOutputs().Count - 1; n >= 0; n--)
            {
                HiddenNeurons[i].getOutputs()[n].RemoveInput(HiddenNeurons[i]);
            }
            HiddenNeurons.RemoveAt(i);
        }

        public int Count(byte nm)
        {
            switch (nm)
            {
                case 0:
                    return InNeurons.Count;
                case 1:
                    return HiddenNeurons.Count;
                case 2:
                    return OutNeurons.Count;
                case 3:
                    return InNeurons.Count + HiddenNeurons.Count + OutNeurons.Count;
                default:
                    return -1;
            }
        }

        public Network<E> CloneNetwork()
        {
            Network<E> opt = new Network<E>();

            foreach (HiddenNeuron<E> hn in HiddenNeurons)
            {
                opt.AddHiddenNeuron(hn.operation);
                List<E> adprm = new List<E>();
                adprm.AddRange(hn.AdditionalParameters);
                opt.HiddenNeurons[opt.HiddenNeurons.Count - 1].AdditionalParameters = adprm;
            }
            foreach (InputNeuron<E> n in InNeurons)
            {
                opt.AddInputNeuron();
            }
            foreach (OutputNeuron<E> n in OutNeurons)
            {
                opt.AddOutputNeuron(n.operation);
            }

            for (int n = 0; n < InNeurons.Count; n++)
            {
                foreach (Neuron nrn in InNeurons[n].getOutputs())
                {
                    if (nrn is HiddenNeuron<E>)
                    {
                        if (!opt.ConnectIH(n, HiddenNeurons.IndexOf((HiddenNeuron<E>)nrn)))
                            Console.Out.WriteLine("InToHidden Fail");
                    }
                    else if (nrn is OutputNeuron<E>)
                    {
                        if (!opt.ConnectIO(n, OutNeurons.IndexOf((OutputNeuron<E>)nrn)))
                            Console.Out.WriteLine("InToOut Fail");
                    }
                }
            }

            for (int n = 0; n < HiddenNeurons.Count; n++)
            {
                foreach (Neuron nrn in HiddenNeurons[n].getOutputs())
                {
                    if (nrn is HiddenNeuron<E>)
                    {
                        if (!opt.ConnectH(n, HiddenNeurons.IndexOf((HiddenNeuron<E>)nrn)))
                            Console.Out.WriteLine("HiddenToHidden Fail");
                    }
                    else if (nrn is OutputNeuron<E>)
                    {
                        if (!opt.ConnectHO(n, OutNeurons.IndexOf((OutputNeuron<E>)nrn)))
                            Console.Out.WriteLine("HiddenToOut Fail");
                    }
                }
            }
            //Console.Out.WriteLine(ToString() + " :: " + opt.ToString());
            return opt;
        }

        public override string ToString()
        {
            return "Network i" + Count(0) + " h" + Count(1) + " o" + Count(2) + " c" + totalConnections;
        }
    }
}﻿using System;
using System.Collections.Generic;

namespace NCodeRiddian
{
    public class Neuron
    {
        protected List<Neuron> inputs;
        protected List<Neuron> outputs;

        public Neuron()
        {
            inputs = new List<Neuron>();
            outputs = new List<Neuron>();
        }

        public bool ConnectOutput(Neuron n)
        {
            if (inputs.Contains(n) || outputs.Contains(n))
                return false;

            outputs.Add(n);
            n.inputs.Add(this);
            return true;
        }

        public bool ConnectInput(Neuron n)
        {
            if (outputs.Contains(n) || inputs.Contains(n))
                return false;

            n.outputs.Add(this);
            inputs.Add(n);
            return true;
        }

        public void Disconnect(Neuron n)
        {
            if (inputs.Remove(n))
                n.outputs.Remove(this);
            if (outputs.Remove(n))
                n.inputs.Remove(this);
        }

        public void Disconnect(Neuron n, bool input)
        {
            if (input)
            {
                inputs.Remove(n);
                n.outputs.Remove(this);
            }
            else
            {
                n.inputs.Remove(n);
                outputs.Remove(this);
            }
        }

        public List<Neuron> getInputs()
        {
            return inputs;
        }

        public List<Neuron> getOutputs()
        {
            return outputs;
        }

        public void RemoveInput(Neuron n)
        {
            inputs.Remove(n);
        }

        public void RemoveOutput(Neuron n)
        {
            outputs.Remove(n);
        }
    }

    public class HiddenNeuron<E> : Neuron
    {
        public delegate bool NeuronOperation(HiddenNeuron<E> n, E[] parameters, List<E> NeuronSpecificParameters);

        public NeuronOperation operation;

        public List<E> AdditionalParameters;

        public HiddenNeuron(NeuronOperation op)
        {
            operation = op;
            AdditionalParameters = new List<E>();
        }

        public void setOperation(NeuronOperation operation)
        {
            this.operation = operation;
            AdditionalParameters = new List<E>();
        }

        public void setOperation(NeuronOperation operation, List<E> AdParam)
        {
            this.operation = operation;
            AdditionalParameters = AdParam;
        }

        public void fireNeuronLimit(int limit, params E[] parameters)
        {
            if (limit <= 0)
                Network<E>.forceKill = true;
            E[] myParams = new E[parameters.Length];
            for (int x = 0; x < parameters.Length; x++)
            {
                myParams[x] = parameters[x];
            }
            if (operation(this, myParams, AdditionalParameters))
            {
                for (int x = outputs.Count - 1; x >= 0; x--)
                {
                    if (Network<E>.forceKill)
                        return;
                    if (outputs[x] is HiddenNeuron<E>)
                    {
                        ((HiddenNeuron<E>)outputs[x]).fireNeuronLimit(limit - 1, myParams);
                    }
                    else if (outputs[x] is OutputNeuron<E>)
                    {
                        ((OutputNeuron<E>)outputs[x]).fireNeuron(myParams);
                    }
                    else
                    {
                        throw new NeuronTypeMismatchException("Type of target Neuron doesn't match this neuron!");
                    }
                }
            }
        }

        public void fireNeuron(params E[] parameters)
        {
            E[] myParams = new E[parameters.Length];
            for (int x = 0; x < parameters.Length; x++)
            {
                myParams[x] = parameters[x];
            }
            if (operation(this, myParams, AdditionalParameters))
            {
                for (int x = outputs.Count - 1; x >= 0; x--)
                {
                    if (outputs[x] is HiddenNeuron<E>)
                    {
                        ((HiddenNeuron<E>)outputs[x]).fireNeuron(myParams);
                    }
                    else if (outputs[x] is OutputNeuron<E>)
                    {
                        ((OutputNeuron<E>)outputs[x]).fireNeuron(myParams);
                    }
                    else
                    {
                        throw new NeuronTypeMismatchException("Type of target Neuron doesn't match this neuron!");
                    }
                }
            }
        }
    }

    public class InputNeuron<E> : Neuron
    {
        public void fireNeuronLimit(int limit, params E[] parameters)
        {
            Network<E>.forceKill = false;
            for (int x = outputs.Count - 1; x >= 0; x--)
            {
                if (outputs[x] is HiddenNeuron<E>)
                {
                    ((HiddenNeuron<E>)outputs[x]).fireNeuronLimit(limit - 1, parameters);
                }
                else if (outputs[x] is OutputNeuron<E>)
                {
                    ((OutputNeuron<E>)outputs[x]).fireNeuron(parameters);
                }
                else
                {
                    throw new NeuronTypeMismatchException("Type of target Neuron doesn't match this neuron!");
                }
            }
        }

        public void fireNeuron(params E[] parameters)
        {
            for (int x = outputs.Count - 1; x >= 0; x--)
            {
                if (outputs[x] is HiddenNeuron<E>)
                {
                    ((HiddenNeuron<E>)outputs[x]).fireNeuron(parameters);
                }
                else if (outputs[x] is OutputNeuron<E>)
                {
                    ((OutputNeuron<E>)outputs[x]).fireNeuron(parameters);
                }
                else
                {
                    throw new NeuronTypeMismatchException("Type of target Neuron doesn't match this neuron!");
                }
            }
        }
    }

    public class OutputNeuron<E> : Neuron
    {
        public delegate void DoOperation(Neuron n, params E[] parameters);

        public DoOperation operation;

        public OutputNeuron(DoOperation op)
        {
            operation = op;
        }

        public void fireNeuron(params E[] parameters)
        {
            operation(this, parameters);
        }
    }

    public class NeuronTypeMismatchException : Exception
    {
        public NeuronTypeMismatchException(string s)
            : base(s)
        {
        }
    }
}﻿using System.Collections.Generic;
using Microsoft.Xna.Framework;
using Microsoft.Xna.Framework.Graphics;

namespace NCodeRiddian
{
    public class ParticleManager2
    {
        public static Stack<Particle2> ParticlePool;
        public static bool enablePooling;
        public static int maxPool;

        static ParticleManager2()
        {
            ParticlePool = new Stack<Particle2>();
            enablePooling = true;
            maxPool = 400;
        }

        public static ColorSet COLORSET_FIRE = new ColorSet(new Color[] { Color.Red, Color.Red, Color.Red, Color.OrangeRed, Color.OrangeRed, Color.Orange, Color.Yellow, Color.Yellow, Color.Yellow, Color.LightYellow });

        public List<Particle2> Particles;

        public List<ParticleEffect2> ActiveEffects;

        public ParticleManager2()
        {
            Particles = new List<Particle2>();
            ActiveEffects = new List<ParticleEffect2>();
        }

        public void update()
        {
            foreach (ParticleEffect2 pe in ActiveEffects)
            {
                Particle2[] temp = pe.update();
                if (temp != null && temp.Length > 0)
                {
                    Particles.AddRange(temp);
                }
            }
            foreach (Particle2 p in Particles)
                p.update();

            ActiveEffects.RemoveAll(x => !x.isActive);
            int idx = Particles.Count - 1;
            if (enablePooling && ParticlePool.Count < maxPool)
            {
                for (idx = Particles.Count - 1; idx >= 0 && ParticlePool.Count < maxPool; idx--)
                {
                    if (!Particles[idx].isActive)
                    {
                        ParticlePool.Push(Particles[idx]);
                        Particles.RemoveAt(idx);
                    }
                }
            }
            while (idx >= 0)
            {
                if (!Particles[idx].isActive)
                {
                    Particles.RemoveAt(idx);
                }
                idx--;
            }
        }

        public void Draw(SpriteBatch sb)
        {
            foreach (Particle2 p in Particles)
                p.Draw(sb);
        }
    }

    public class ParticleEffect2
    {
        public delegate Particle2[] UpdateEffect(ParticleEffect2 effect);

        public bool isActive;
        public int time;
        public object[] param;
        public UpdateEffect myUpdate;

        public ParticleEffect2(UpdateEffect updatemethod, object[] param)
        {
            this.param = param;
            myUpdate = updatemethod;
            time = 0;
            isActive = true;
        }

        public ParticleEffect2(UpdateEffect ue)
            : this(ue, null)
        {
        }

        public Particle2[] update()
        {
            time++;
            return myUpdate(this);
        }
    }

    public class Particle2
    {
        public delegate void UpdateMethod(Particle2 particle);

        public delegate void OverDrawMethod(Particle2 particle, SpriteBatch sb);

        public Vector2 position;
        public Vector2 velocity;
        public int time;
        public int size;
        public UpdateMethod myUpdate;
        public OverDrawMethod DrawOver;
        public OverDrawMethod DrawUnder;
        public Color c;
        public bool isActive;

        public Particle2(Vector2 pos, Vector2 vel, UpdateMethod mymeth, Color c, int s)
        {
            UNPOOL(pos, vel, mymeth, c, s);
        }

        public static Particle2 GetNew(Vector2 pos, Vector2 vel, UpdateMethod mymeth, Color c, int s)
        {
            if (ParticleManager2.ParticlePool.Count > 0)
            {
                return ParticleManager2.ParticlePool.Pop().UNPOOL(pos, vel, mymeth, c, s);
            }
            return new Particle2(pos, vel, mymeth, c, s);
        }

        internal Particle2 UNPOOL(Vector2 pos, Vector2 vel, UpdateMethod mymeth, Color c, int s)
        {
            position = pos;
            velocity = vel;
            myUpdate = mymeth;
            time = 0;
            this.c = c;
            size = s;
            isActive = true;
            return this;
        }

        public void update()
        {
            myUpdate(this);
            time++;
        }

        public void Draw(SpriteBatch sb)
        {
            if (DrawUnder != null)
                DrawUnder(this, sb);
            Camera.drawGeneric(sb, MemSave.getr((int)position.X, (int)position.Y, size, size), c, null, 0, Vector2.Zero, SpriteEffects.None, 0);
            if (DrawOver != null)
                DrawOver(this, sb);
        }
    }
}﻿using System;
using System.Collections.Generic;
using Microsoft.Xna.Framework;

namespace NCodeRiddian
{
    public abstract class A_Path<T>
    {
        protected List<T> path;

        public A_Path()
        {
            path = new List<T>();
        }

        public A_Path(List<T> use)
        {
            path = use;
        }

        public List<T> GetPath()
        {
            return path;
        }

        public T GetLast()
        {
            if (path.Count <= 0)
                throw new IndexOutOfRangeException("Path is Empty - Can't get Last");
            return path[path.Count - 1];
        }

        public virtual T Get(int i)
        {
            if (i < 0 || i > path.Count)
                throw new IndexOutOfRangeException(i + " is out of range of path (length:" + path.Count + ")");
            return path[i];
        }

        public virtual T GetNext(T item)
        {
            int i = path.IndexOf(item) + 1;
            if (i == 0)
                throw new IndexOutOfRangeException(item + " not contained in path");
            if (i == path.Count)
                return path[path.Count - 1];
            return path[i];
        }

        public virtual T GetNext(int i)
        {
            i++;
            if (i <= 0)
                throw new IndexOutOfRangeException(i + " Out of range of path");
            if (i == path.Count)
                return path[path.Count - 1];
            return path[i];
        }

        public virtual void Add(T item)
        {
            path.Add(item);
        }

        public abstract bool isValid(T t);

        public bool isValid(int i)
        {
            return isValid(path[i]);
        }

        public bool VerifyPath()
        {
            foreach (T t in path)
                if (!isValid(t))
                    return false;
            return true;
        }

        public virtual List<T> ReversePath()
        {
            List<T> pth = new List<T>();
            for (int x = path.Count - 1; x >= 0; x--)
                pth.Add(path[x]);
            return pth;
        }
    }

    public class Path : A_Path<Pathable>
    {
        public Rectangle maxRec;

        public Path()
            : base()
        {
            path = new List<Pathable>();
        }

        public Path(Pathable s)
            : base()
        {
            path = new List<Pathable>();
            path.Add(s);
        }

        public Path(Path p, Pathable add)
            : base()
        {
            path = new List<Pathable>();

            foreach (Pathable s in p.path)
                Add(s);
            if (add != null)
            {
                Add(add);
            }
        }

        public override void Add(Pathable s)
        {
            if (maxRec.Width == 0 && maxRec.Height == 0)
            {
                maxRec = new Rectangle(((Pathable)((Pathable)s)).getTrueRectangle().X, ((Pathable)s).getTrueRectangle().Y, ((Pathable)s).getTrueRectangle().Width, ((Pathable)s).getTrueRectangle().Height);
            }
            path.Add(s);
            if (((Pathable)s).getTrueRectangle().X < maxRec.X)
            {
                maxRec.Width += maxRec.X - ((Pathable)s).getTrueRectangle().X;
                maxRec.X = ((Pathable)s).getTrueRectangle().X;
            }
            if (((Pathable)s).getTrueRectangle().Y < maxRec.Y)
            {
                maxRec.Height += maxRec.Y - ((Pathable)s).getTrueRectangle().Y;
                maxRec.Y = ((Pathable)s).getTrueRectangle().Y;
            }
            if (((Pathable)s).getTrueRectangle().X > maxRec.X + maxRec.Width)
            {
                maxRec.Width = ((Pathable)s).getTrueRectangle().X - maxRec.X;
            }
            if (((Pathable)s).getTrueRectangle().Y > maxRec.Y + maxRec.Height)
            {
                maxRec.Height = ((Pathable)s).getTrueRectangle().Y - maxRec.Y;
            }
        }

        public Path reverse()
        {
            Path newPath = new Path();
            for (int x = path.Count - 1; x >= 0; x--)
                newPath.Add(path[x]);

            return newPath;
        }

        public static int S_COMPAIR(Path p1, Path p2)
        {
            return p1.path.Count - p2.path.Count;
        }

        public bool verifyPath()
        {
            foreach (Pathable s in path)
            {
                if (((Pathable)s).isValid())
                {
                    path.Clear();
                    return false;
                }
            }

            return true;
        }

        public bool contain(Pathable s)
        {
            return path.Contains(s);
        }

        public Pathable getLast()
        {
            if (path.Count > 0)
                return path[path.Count - 1];
            else
                return default(Pathable);
        }

        public Pathable getFirst()
        {
            if (path.Count > 0)
                return path[0];
            else
                return default(Pathable);
        }

        public Pathable getNext(Pathable current)
        {
            if (current == null)
                return null;
            for (int x = 0; x < path.Count - 1; x++)
                if (current.Equals(path[x]))
                    return path[x + 1];

            return default(Pathable);
        }

        public override string ToString()
        {
            return "Path-" + path.Count;
        }

        public override bool isValid(Pathable t)
        {
            return t.isValid();
        }
    }
}﻿using System.Collections.Generic;
using Microsoft.Xna.Framework;

namespace NCodeRiddian
{
    public interface Pathable
    {
        /// <summary>
        /// Returns the value (Lower = favored) of moving from the previous pathable to the current pathable
        /// </summary>
        /// <param name="previous">The previous step in the path</param>
        /// <returns></returns>
        float getMoveScore(Pathable previous);

        /// <summary>
        /// Returns the vale (Lower = favored) of the heuristic score from the current pathable to the target pathable
        /// </summary>
        /// <param name="target"></param>
        /// <returns></returns>
        float getHeuristicScore(Pathable target);

        /// <summary>
        /// Returns the centered rectangle of this object
        /// </summary>
        /// <returns></returns>
        Rectangle getTrueRectangle();

        /// <summary>
        /// Return whether or not this pathable is still valid
        /// </summary>
        /// <returns></returns>
        bool isValid();

        /// <summary>
        /// Returns a list of all Pathables that could be reached from this Pathable
        /// </summary>
        /// <returns></returns>
        List<Pathable> getConnected();
    }
}﻿using System;
using System.Collections.Generic;

namespace NCodeRiddian
{
    abstract public class Pather
    {
        private static List<PathNode> closedList = new List<PathNode>();

        public static Path GeneratePath(Pathable s, Pathable endPoint)
        {
            closedList.Clear();
            OpenHeap.openHeap.Clear();

            PathNode start = new PathNode(s, endPoint);
            start.setF(0);
            closedList.Add(start);

            foreach (Pathable s2 in start.element.getConnected())
            {
                OpenHeap.addToHeap(new PathNode(s2, endPoint, start));
            }

            bool done = false;
            while (!done)
            {
                if (OpenHeap.openHeap.Count == 0)
                {
                    return null;
                }

                PathNode next = OpenHeap.removeFirst();

                if (next.element == endPoint)
                {
                    return next.generatePath();
                }

                closedList.Add(next);
                foreach (Pathable s2 in next.element.getConnected())
                {
                    PathNode pnext = new PathNode(s2, endPoint, next);

                    if (!closedList.Contains(pnext))
                    {
                        if (!OpenHeap.contains(pnext))
                        {
                            OpenHeap.addToHeap(pnext);
                        }
                        else
                        {
                            if (OpenHeap.openHeap[OpenHeap.openHeap.IndexOf(pnext)].F > pnext.F)
                            {
                                OpenHeap.openHeap[OpenHeap.openHeap.IndexOf(pnext)].parentNode = next;
                                OpenHeap.openHeap[OpenHeap.openHeap.IndexOf(pnext)].setF(next);
                            }
                            else
                            {
                            }
                        }
                    }
                }
            }

            return null;
        }
    }

    internal class OpenHeap
    {
        public static List<PathNode> openHeap = new List<PathNode>();

        public static bool contains(PathNode pn)
        {
            return openHeap.Contains(pn);
        }

        public static PathNode removeFirst()
        {
            if (openHeap.Count != 0)
            {
                PathNode toRemove = openHeap[0];
                openHeap.RemoveAt(0);
                if (openHeap.Count != 0)
                {
                    openHeap.Insert(0, openHeap[openHeap.Count - 1]);
                    openHeap.RemoveAt(openHeap.Count - 1);
                    sortHeap();
                }

                return toRemove;
            }
            return null;
        }

        public static void addToHeap(PathNode add)
        {
            openHeap.Add(add);
            sortDown(openHeap.Count - 1);
        }

        public static void sortDown(int i)
        {
            bool done = false;
            if (openHeap.Count < 2)
                return;
            while (!done)
            {
                if (i != 0 && openHeap[i].G < openHeap[H_getParent(i)].G)
                {
                    swap(i, H_getParent(i));
                    i = H_getParent(i);
                }
                else
                    done = true;
            }
        }

        public static void sortHeap()
        {
            bool done = false;
            int t1 = 0;
            while (!done)
            {
                if (H_getTeir(t1) == H_getTeir(openHeap.Count - 1))
                    return;

                PathNode child1 = null;
                PathNode child2 = null; ;
                if (H_getChild(t1, false) < openHeap.Count)
                {
                    child2 = openHeap[H_getChild(t1, false)];
                    child1 = openHeap[H_getChild(t1, true)];
                }
                else if (H_getChild(t1, true) < openHeap.Count)
                {
                    child1 = openHeap[H_getChild(t1, true)];
                }

                if (child1 == null)
                {
                    done = true;
                }
                else if (child2 == null)
                {
                    done = true;
                    if (child1.G > openHeap[t1].G)
                        swap(H_getChild(t1, true), t1);
                }
                else
                {
                    bool ChildOneLess = child1.G < openHeap[t1].G;
                    bool ChildTwoLess = child2.G < openHeap[t1].G;

                    if (ChildOneLess && ChildTwoLess)
                    {
                        if (child1.G < child2.G)
                        {
                            swap(H_getChild(t1, true), t1);
                            t1 = H_getChild(t1, true);
                        }
                        else
                        {
                            swap(H_getChild(t1, false), t1);
                            t1 = H_getChild(t1, false);
                        }
                    }
                    else if (ChildOneLess)
                    {
                        swap(H_getChild(t1, true), t1);
                        t1 = H_getChild(t1, true);
                    }
                    else if (ChildTwoLess)
                    {
                        swap(H_getChild(t1, false), t1);
                        t1 = H_getChild(t1, false);
                    }
                    else
                    {
                        done = true;
                    }
                }
            }
        }

        public static void swap(int idx1, int idx2)
        {
            PathNode temp = openHeap[idx1];
            openHeap[idx1] = openHeap[idx2];
            openHeap[idx2] = temp;
        }

        public static int H_getTeir(int idx)
        {
            return (int)(Math.Log((idx % 2 == 0 ? 0 : 1) + idx + 1) / Math.Log(2));
        }

        public static int H_getTeirIdx(int idx)
        {
            return (int)(idx - ((int)Math.Pow(2, H_getTeir(idx)))) + 1;
        }

        public static int H_getTotalIdx(int idx, int tier)
        {
            return (int)(Math.Pow(2, tier) + idx);
        }

        public static int H_getChild(int idx, bool left)
        {
            return (int)(idx * 2) + (left ? 1 : 2);
        }

        public static int H_getParent(int idx)
        {
            return H_getTotalIdx(H_getTeirIdx(idx) / 2, H_getTeir(idx) - 1) - 1;
        }
    }

    internal class PathNode
    {
        public Pathable element;
        public PathNode parentNode;
        public float F; //Pathed score
        public float H; //Heuristic Score
        public float G; //Global Score

        public override bool Equals(object obj)
        {
            return obj is PathNode && ((PathNode)obj).element.Equals(element);
        }

        public PathNode(Pathable s, Pathable hub)
        {
            parentNode = null;
            element = s;
            H = s.getHeuristicScore(hub);
        }

        public PathNode(Pathable s, Pathable hub, PathNode parent)
        {
            parentNode = parent;
            element = s;
            H = s.getHeuristicScore(hub);

            setF(parent.F + s.getMoveScore(parentNode.element));
        }

        public void setF(PathNode pnode)
        {
            setF(pnode.F + pnode.element.getMoveScore(element));
        }

        public void setF(float f)
        {
            F = f;
            G = H + F;
        }

        public Path generatePath()
        {
            return generatePathHelper(new Path()).reverse();
        }

        public Path generatePathHelper(Path p)
        {
            p.Add(element);
            if (parentNode == null)
            {
                return p;
            }
            else
            {
                return parentNode.generatePathHelper(p);
            }
        }
    }
}﻿using System.Collections.Generic;

namespace NCodeRiddian
{
    public class Pather2
    {
        public static Path GeneratePath(Pathable start, Pathable end)
        {
            OpenHeap2 openList = new OpenHeap2();
            List<PathNode> closedList = new List<PathNode>();
            Pathable next = start;
            PathNode thefirst = new PathNode(next, end);
            thefirst.setF(0);
            closedList.Add(thefirst);

            foreach (Pathable s2 in thefirst.element.getConnected())
            {
                openList.openHeap.Add(new PathNode(s2, end, thefirst));
            }

            while (openList.openHeap.Count > 0)
            {
                PathNode nextpathnode = openList.getFirst();
                closedList.Add(nextpathnode);

                if (nextpathnode.element == end)
                {
                    return nextpathnode.generatePath();
                }

                foreach (Pathable s2 in nextpathnode.element.getConnected())
                {
                    PathNode pn = new PathNode(s2, end, nextpathnode);
                    if (closedList.Contains(pn)) { }
                    else if (openList.contains(pn))
                    {
                        int index = openList.openHeap.IndexOf(pn);
                        if (openList.openHeap[index].F > nextpathnode.F)
                        {
                            openList.openHeap[index].parentNode = nextpathnode;
                            openList.openHeap[index].setF(nextpathnode);
                        }
                        else { }
                    }
                    else openList.add(pn);
                }
            }

            return null;
        }
    }

    internal class OpenHeap2
    {
        public List<PathNode> openHeap;

        public OpenHeap2()
        {
            openHeap = new List<PathNode>();
        }

        public bool contains(PathNode pn)
        {
            return openHeap.Contains(pn);
        }

        public PathNode getFirst()
        {
            PathNode toreturn = openHeap[0];
            swap(0, openHeap.Count - 1);
            openHeap.RemoveAt(openHeap.Count - 1);
            sortDown();
            return toreturn;
        }

        public void add(PathNode item)
        {
            openHeap.Add(item);
            sortUp();
        }

        private void swap(int i, int i2)
        {
            PathNode temp = openHeap[i];
            openHeap[i] = openHeap[i2];
            openHeap[i2] = temp;
        }

        private void sortUp(int i)
        {
            PathNode current = openHeap[i];
            PathNode parent = getParent(i) >= 0 ? openHeap[getParent(i)] : null;
            if (parent == null || current.G <= parent.G)
                return;

            swap(i, getParent(i));
            sortUp(getParent(i));
        }

        private void sortUp()
        {
            sortUp(openHeap.Count - 1);
        }

        private void sortDown(int i)
        {
            int[] childIndecies = getChildren(i);

            if (childIndecies[0] >= openHeap.Count)
                return;

            PathNode[] children = new PathNode[] { openHeap[childIndecies[0]], childIndecies[1] < openHeap.Count ? openHeap[childIndecies[1]] : null };
            int greaterIndex;

            if (children[1] == null || children[0].G > children[1].G)
                greaterIndex = 0;
            else
                greaterIndex = 1;

            if (openHeap[i].G < children[greaterIndex].G)
            {
                swap(i, childIndecies[greaterIndex]);
                sortDown(childIndecies[greaterIndex]);
            }
        }

        private void sortDown()
        {
            sortDown(0);
        }

        private static int[] getChildren(int i)
        {
            return new int[] { (i + 1) * 2 - 1, ((i + 1) * 2) };
        }

        private static int getParent(int i)
        {
            return (int)(i / 2);
        }
    }
}﻿using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;

namespace NCodeRiddian
{
    public class Perlin
    {
        public static float[,] Generate(int size)
        {
            float[,] flt = new float[size, size];
            for (int x = 0; x < size; x++)
            {
                for (int y = 0; y < size; y++)
                {
                    flt[x, y] = .5f;
                }
            }

            int numLayers = (int)Math.Ceiling(Math.Log(size) / Math.Log(2));
            for (int l = 0; l < numLayers; l++)
            {
                GenerateOctave(flt, (int)Math.Ceiling(size / Math.Pow(2, l)), (float)(numLayers - l) / numLayers);
            }

            for (int x = 0; x < size; x++)
            {
                for (int y = 0; y < size; y++)
                {
                    flt[x, y] = Math.Min(1, Math.Max(0, flt[x, y]));
                }
            }

            return flt;
        }

        private static void GenerateOctave(float[,] orig, int size, float limit)
        {
            for (int x = 0; x < orig.GetLength(0); x += size)
            {
                for (int y = 0; y < orig.GetLength(1); y += size)
                {
                    for (int dx = 0; dx < size && dx + x < orig.GetLength(0); dx++)
                    {
                        for (int dy = 0; dy < size && dy + y < orig.GetLength(0); dy++)
                        {
                            orig[x + dx, y + dy] += (float)GlobalRandom.NextBetween(-limit / 2, limit / 2);
                        }
                    }
                }
            }
        }

        public static float[,] Smooth(float[,] flt, int radius)
        {
            for (int x = 0; x < flt.GetLength(0); x++)
            {
                for (int y = 0; y < flt.GetLength(1); y++)
                {
                    float sum = 0;
                    float numChecked = 0;
                    for (int dx = x - radius; dx <= x + radius; dx++)
                    {
                        for (int dy = y - radius; dy <= y + radius; dy++)
                        {
                            if (dx > 0 && dy > 0 && dx < flt.GetLength(0) && dy < flt.GetLength(1))
                            {
                                numChecked++;
                                sum += flt[dx, dy];
                            }
                        }
                    }
                    flt[x, y] = sum / numChecked;
                }
            }
            return flt;
        }
    }
}
﻿using Microsoft.Xna.Framework;

namespace NCodeRiddian
{
    public abstract class PointM
    {
        public static Point Add(Point p1, int x, int y)
        {
            return new Point(p1.X + x, p1.Y + y);
        }

        public static int Sum(Point p1)
        {
            return p1.X + p1.Y;
        }

        public static void Add(ref Point p1, int x, int y)
        {
            p1.X += x;
            p1.Y += y;
        }

        public static Point Multiply(Point p1, int x, int y)
        {
            return new Point(p1.X * x, p1.Y * y);
        }

        public static void Multiply(ref Point p1, int x, int y)
        {
            p1.X *= x;
            p1.Y *= y;
        }

        public static Point Divide(Point p1, int x, int y)
        {
            return new Point(p1.X / x, p1.Y / y);
        }

        public static void Divide(ref Point p1, int x, int y)
        {
            p1.X /= x;
            p1.Y /= y;
        }

        public static bool Assure(Point p, int lowx, int highx, int lowy, int highy)
        {
            return p.X >= lowx && p.X < highx && p.Y >= lowy && p.Y < highy;
        }
    }
}﻿using Microsoft.Xna.Framework;
using Microsoft.Xna.Framework.Graphics;

namespace NCodeRiddian
{
    public abstract class PostProcessing
    {
        protected static GraphicsDeviceManager graphics;
        protected static SpriteBatch spriteBatch;
        protected static RenderTarget2D screenDump;

        public static void Enable(GraphicsDeviceManager gm, SpriteBatch sb)
        {
            graphics = gm;
            spriteBatch = sb;
            screenDump = new RenderTarget2D(gm.GraphicsDevice, gm.PreferredBackBufferWidth, gm.PreferredBackBufferHeight);
        }

        public static void startDrawing()
        {
            graphics.GraphicsDevice.SetRenderTarget(screenDump);
            graphics.GraphicsDevice.Clear(new Color(0, 0, 0, 0));
            spriteBatch.Begin();
        }

        protected static Color[] applyEffect(Color[] colors)
        {
            return colors;
        }

        public static void endDrawing()
        {
            spriteBatch.End();

            graphics.GraphicsDevice.SetRenderTarget(null);
            graphics.GraphicsDevice.Clear(Color.CornflowerBlue);

            Color[] colorArray = new Color[screenDump.Width * screenDump.Height];
            screenDump.GetData<Color>(colorArray);
            colorArray = applyEffect(colorArray);
            screenDump.SetData<Color>(colorArray);
            spriteBatch.Begin();

            spriteBatch.Draw(screenDump, new Vector2(0, 0), Color.White);

            spriteBatch.End();
        }
    }
}using System;
using System.Collections.Generic;
using System.IO;
using Microsoft.Xna.Framework;
using Microsoft.Xna.Framework.Content;
using Microsoft.Xna.Framework.Graphics;

namespace NCodeRiddian
{
    public abstract class TextureManager
    {
        private static List<TextureManagerDefinition> definitions = new List<TextureManagerDefinition>();
        private static List<FontManagerDefinition> fontdefinitions = new List<FontManagerDefinition>();
        private static bool debug = false;
        private static Texture2D generic;

        public static Texture2D getGeneric()
        {
            return generic;
        }

        public static void setupGeneric(GraphicsDevice gd)
        {
            generic = new Texture2D(gd, 1, 1);
            generic.SetData<Color>(new Color[] { Color.White });
        }

        public static void setDebug(bool debug)
        {
            TextureManager.debug = debug;
        }

        public static void loadAllImages(ContentManager cm)
        {
            foreach (string s in Directory.GetFiles("Content", "*", SearchOption.AllDirectories))
            {
                try
                {
                    definitions.Add(new TextureManagerDefinition(s, cm));
                    if (debug)
                    {
                        Console.WriteLine("NCodeRiddian.TextureManager Debug:DefinitionAdded:\"" + definitions[definitions.Count - 1].name + "\"");
                    }
                }
                catch (InvalidFileException e)
                {
                    try
                    {
                        fontdefinitions.Add(new FontManagerDefinition(s, cm));
                        if (debug)
                        {
                            Console.WriteLine("NCodeRiddian.TextureManager Debug: DefinitionAdded:\"" + fontdefinitions[fontdefinitions.Count - 1].name + "\"");
                        }
                    }
                    catch (InvalidFileException e2)
                    {
                    }
                }
            }
        }

        public static Texture2D getTexture(string n)
        {
            foreach (TextureManagerDefinition tmd in definitions)
            {
                if (tmd.name.Equals(n))
                    return tmd.image;
            }
            if (debug)
            {
                Console.Out.WriteLine("Failure, No Definition for Name \"{0}\"", n);
            }
            return null;
        }

        public static SpriteFont getFont(string n)
        {
            int idx = fontdefinitions.FindIndex(x => x.name.Equals(n));
            if (idx == -1)
            {
                if (debug)
                {
                    Console.Out.WriteLine("Failure, No Definition for Name \"{0}\"", n);
                }
            }
            return fontdefinitions[idx].font;
        }
    }

    internal class TextureManagerDefinition
    {
        public string name;
        public Texture2D image;

        public TextureManagerDefinition(string fileloc, ContentManager cm)
        {
            try
            {
                image = cm.Load<Texture2D>(fileloc.Substring(8).Split('.')[0]);
                name = fileloc.Substring(8).Split('.')[0];
            }
            catch (Exception e) { throw new InvalidFileException(); }
        }
    }

    internal class FontManagerDefinition
    {
        public string name;
        public SpriteFont font;

        public FontManagerDefinition(string fileloc, ContentManager cm)
        {
            try
            {
                font = cm.Load<SpriteFont>(fileloc.Substring(8).Split('.')[0]);
                name = fileloc.Substring(8).Split('.')[0];
            }
            catch (Exception e) { throw new InvalidFileException(); }
        }
    }

    internal class InvalidFileException : Exception
    {
    }
}﻿using System.Collections.Generic;
using Microsoft.Xna.Framework;
using Microsoft.Xna.Framework.Graphics;

namespace NCodeRiddian
{
    public class WrappedText
    {
        private List<string> lines;
        private SpriteFont sf;
        private string orig;
        private int wid;

        public WrappedText(string str, int width, SpriteFont font)
        {
            lines = new List<string>();
            orig = str;
            wid = width;
            sf = font;
            generate(str);
        }

        public void changeSize(int wid)
        {
            lines.Clear();
            this.wid = wid;
            generate();
        }

        public void changeString(string str)
        {
            lines.Clear();
            orig = str;
            generate(str);
        }

        public int getWidth()
        {
            return wid;
        }

        public float getHeight(float spacing)
        {
            return lines.Count * sf.MeasureString(lines[0]).Y * spacing;
        }

        private void generate(string str)
        {
            string[] words = str.Split(' ');
            string curString = words[0];
            for (int i = 1; i < words.Length; i++)
            {
                if (sf.MeasureString(curString + " " + words[i]).X > wid)
                {
                    lines.Add(curString);
                    curString = words[i];
                }
                else
                    curString += " " + words[i];
            }
            if (curString.Equals(""))
            { }
            else
                lines.Add(curString);
        }

        private void generate()
        {
            generate(orig);
        }

        public void draw(SpriteBatch sb, Point p, float spacing, Color color)
        {
            spacing *= (float)sf.MeasureString(lines[0]).Y;
            for (int i = 0; i < lines.Count; i++)
            {
                sb.DrawString(sf, lines[i], new Vector2(p.X, p.Y + (spacing * i)), color);
            }
        }

        public void draw(SpriteBatch sb, Vector2 v, float spacing, Color color)
        {
            spacing *= (float)sf.MeasureString(lines[0]).Y;
            for (int i = 0; i < lines.Count; i++)
            {
                sb.DrawString(sf, lines[i], new Vector2(v.X, v.Y + (spacing * i)), color);
            }
        }
    }
}